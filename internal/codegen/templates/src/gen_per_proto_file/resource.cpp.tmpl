// THIS FILE IS GENERATED BY GDBUF. DO NOT EDIT UNLESS YOU KNOW WHAT YOU'RE DOING
{{- $protoPathNoExtension := trimSuffix ".proto" .ProtoPath }}
{{- $protoFileNameNoExtension := base $protoPathNoExtension }}
{{- $packageName := .PackageName }}
#include <string>
#include "{{ $protoFileNameNoExtension }}.h"
#include "{{ $protoFileNameNoExtension }}.pb.h"
#include <cstdint> // Required for int64_t
#include <godot_cpp/variant/string.hpp>
#include <godot_cpp/variant/packed_string_array.hpp>
#include "messages.h" // Include the shared utils
{{- range .Dependencies }}
#include "{{ . }}"
{{- end }}


namespace gdbuf {
namespace {{ snakecase $protoFileNameNoExtension }} {
{{- range .Messages }}
{{- $className := .ClassName }}

void {{ $className }}::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &{{ $className }}::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &{{ $className }}::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &{{ $className }}::from_byte_array);

  {{- range .Oneofs }}
  godot::ClassDB::bind_method(godot::D_METHOD("get_{{ snakecase .Name }}_case"), &{{ $className }}::get_{{ snakecase .Name }}_case);
  {{- range .Fields }}
  BIND_ENUM_CONSTANT(k{{ toPascalCase .FieldName }});
  {{- end }}
  BIND_ENUM_CONSTANT({{ toUpper (snakecase .Name) }}_NOT_SET);
  {{- end }}

  {{- range .Fields }}
  godot::ClassDB::bind_method(godot::D_METHOD("get_{{ snakecase .FieldName }}"), &{{ $className }}::get_{{ snakecase .FieldName }});
  godot::ClassDB::bind_method(godot::D_METHOD("set_{{ snakecase .FieldName }}", "value"), &{{ $className }}::set_{{ snakecase .FieldName }});
  godot::ClassDB::add_property("{{ $className }}", godot::PropertyInfo({{ godotVariantType .GodotType .IsCustomType .IsEnum }}, "{{ snakecase .FieldName }}"
      {{- if .IsCustomType }}, godot::PROPERTY_HINT_RESOURCE_TYPE, "{{ .GodotClassName }}"
      {{- else if .IsRepeated }}, godot::PROPERTY_HINT_TYPE_STRING, "{{ .GodotClassName }}:{{ .InnerGodotClassName }}"
      {{- end }}
      ), "set_{{ snakecase .FieldName }}", "get_{{ snakecase .FieldName }}");
  {{- end }}
}

godot::String {{ $className }}::get_proto_file_name() {
  return godot::String("{{ $protoFileNameNoExtension }}");
}

godot::String {{ $className }}::_to_string() const {
    {{- $cppNamespace := replace "." "::" $packageName }}
    {{ if $cppNamespace }}::{{ $cppNamespace }}::{{ else }}::{{ end }}{{ .MessageName }} proto_msg;
    godot::PackedByteArray bytes = this->to_byte_array();
    if (proto_msg.ParseFromArray(bytes.ptr(), bytes.size())) {
        godot::String result;
        // Append Oneof Case Information
        {{- range .Oneofs }}
        result += "{{ .Name }} case: ";
        switch (this->{{ snakecase .Name }}_case) {
            case {{ toUpper (snakecase .Name) }}_NOT_SET: result += "NOT_SET"; break;
            {{- range .Fields }}
            case k{{ toPascalCase .FieldName }}: result += "k{{ toPascalCase .FieldName }}"; break;
            {{- end }}
        }
        result += "\n";
        {{- end }}
        result += godot::String(proto_msg.DebugString().c_str());
        return result;
    }
    return godot::String("{{ $className }} <failed to serialize>");
}

// Serialize
godot::PackedByteArray {{ $className }}::to_byte_array() const {
    {{- $cppNamespace := replace "." "::" $packageName }}
    {{ if $cppNamespace }}::{{ $cppNamespace }}::{{ else }}::{{ end }}{{ .MessageName }} proto_msg; 

    {{- range .Fields }}
    {{- if .IsRepeated }}
    // --- Repeated Field ---
    godot::Array {{ snakecase .FieldName }}_arr = this->{{ snakecase .FieldName }};
    for (int i = 0; i < {{ snakecase .FieldName }}_arr.size(); i++) {
        {{- if .IsInnerCustomType }}
        godot::Object* obj = {{ snakecase .FieldName }}_arr[i];
        {{ .InnerGodotType }}* wrapper = godot::Object::cast_to<{{ .InnerGodotType }}>(obj);
        if (wrapper) {
             godot::PackedByteArray child_bytes = wrapper->to_byte_array();
             proto_msg.add_{{ .FieldName }}()->ParseFromArray(child_bytes.ptr(), child_bytes.size());
        }
        {{- else if eq .InnerGodotType "godot::String" }}
        proto_msg.add_{{ .FieldName }}(((godot::String){{ snakecase .FieldName }}_arr[i]).utf8().get_data());
        {{- else if .IsEnum }}
        {{- $enumType := replace "." "::" (trimPrefix "." .ProtoTypeName) }}
        proto_msg.add_{{ .FieldName }}(static_cast<{{ if $enumType }}::{{ $enumType }}{{ else }}int{{ end }}>((int64_t){{ snakecase .FieldName }}_arr[i]));
        {{- else }}
        proto_msg.add_{{ .FieldName }}({{ snakecase .FieldName }}_arr[i]);
        {{- end }}
    }
    {{- else if .IsMap }}
    // --- Map Field ---
    godot::Dictionary {{ snakecase .FieldName }}_dict = this->{{ snakecase .FieldName }};
    godot::Array keys_{{ snakecase .FieldName }} = {{ snakecase .FieldName }}_dict.keys();
    for (int i = 0; i < keys_{{ snakecase .FieldName }}.size(); i++) {
        auto key_var = keys_{{ snakecase .FieldName }}[i];
        auto val_var = {{ snakecase .FieldName }}_dict[key_var];

        // Key
        {{- if eq .MapKeyGodotType "godot::String" }}
        std::string k = ((godot::String)key_var).utf8().get_data();
        {{- else }}
        auto k = ({{ .MapKeyGodotType }})key_var;
        {{- end }}

        // Value
        {{- if .MapValueIsCustom }}
        godot::Object* obj = val_var;
        {{ .MapValueGodotType }}* wrapper = godot::Object::cast_to<{{ .MapValueGodotType }}>(obj);
        if (wrapper) {
             godot::PackedByteArray child_bytes = wrapper->to_byte_array();
             (*proto_msg.mutable_{{ .FieldName }}())[k].ParseFromArray(child_bytes.ptr(), child_bytes.size());
        }
        {{- else if eq .MapValueGodotType "godot::String" }}
        (*proto_msg.mutable_{{ .FieldName }}())[k] = ((godot::String)val_var).utf8().get_data();
        {{- else }}
        (*proto_msg.mutable_{{ .FieldName }}())[k] = ({{ .MapValueGodotType }})val_var;
        {{- end }}
    }
    {{- else }}
    // --- Singular Field ---
    // --- Special WKT Handling ---
    {{- if eq .ProtoTypeName ".google.protobuf.Timestamp" }}
    GDBufUtils::millis_to_timestamp(this->{{ snakecase .FieldName }}, proto_msg.mutable_{{ .FieldName }}());
    {{- else if eq .ProtoTypeName ".google.protobuf.Duration" }}
    proto_msg.mutable_{{ .FieldName }}()->set_seconds((int64_t)this->{{ snakecase .FieldName }});
    {{- else if eq .ProtoTypeName ".google.protobuf.StringValue" }}
    proto_msg.mutable_{{ .FieldName }}()->set_value(this->{{ snakecase .FieldName }}.utf8().get_data());
    {{- else if eq .ProtoTypeName ".google.protobuf.Int32Value" }}
    proto_msg.mutable_{{ .FieldName }}()->set_value(this->{{ snakecase .FieldName }});
    {{- else if eq .ProtoTypeName ".google.protobuf.BoolValue" }}
    proto_msg.mutable_{{ .FieldName }}()->set_value(this->{{ snakecase .FieldName }});
    {{- else if eq .ProtoTypeName ".google.protobuf.Any" }}
    // TODO: Implement Any serialization
    {{- else if eq .ProtoTypeName ".google.protobuf.Empty" }}
    // Empty: no-op
    {{- else if eq .ProtoTypeName ".google.protobuf.FieldMask" }}
    for (int i = 0; i < this->{{ snakecase .FieldName }}.size(); i++) {
        proto_msg.mutable_{{ .FieldName }}()->add_paths(((godot::String)this->{{ snakecase .FieldName }}[i]).utf8().get_data());
    }
    
    // --- Handling WKTs ---
    {{- else if eq .GodotType "godot::Dictionary" }} 
    if (this->{{ snakecase .FieldName }}.size() > 0) {
        GDBufUtils::dictionary_to_struct(this->{{ snakecase .FieldName }}, proto_msg.mutable_{{ .FieldName }}());
    }
    {{- else if eq .GodotType "godot::Variant" }}
    GDBufUtils::variant_to_value(this->{{ snakecase .FieldName }}, *proto_msg.mutable_{{ .FieldName }}());
    {{- else if eq .GodotType "godot::Array" }}
    GDBufUtils::array_to_list_value(this->{{ snakecase .FieldName }}, proto_msg.mutable_{{ .FieldName }}());

    // --- Handling Nested Custom Messages ---
    {{- else if .IsCustomType }}
    if (this->{{ snakecase .FieldName }} != nullptr) {
        godot::PackedByteArray child_bytes = this->{{ snakecase .FieldName }}->to_byte_array();
        proto_msg.mutable_{{ .FieldName }}()->ParseFromArray(child_bytes.ptr(), child_bytes.size());
    }

    // --- Handling Primitives with Conversion ---
    {{- else if eq .GodotType "godot::String" }}
    proto_msg.set_{{ .FieldName }}(this->{{ snakecase .FieldName }}.utf8().get_data());
    {{- else if eq .GodotType "godot::PackedByteArray" }}
    {
        godot::PackedByteArray pba = this->{{ snakecase .FieldName }};
        proto_msg.set_{{ .FieldName }}(std::string((const char*)pba.ptr(), pba.size()));
    }
    {{- else if .IsEnum }}
    {{- $enumType := replace "." "::" (trimPrefix "." .ProtoTypeName) }}
    proto_msg.set_{{ .FieldName }}(static_cast<{{ if $enumType }}::{{ $enumType }}{{ else }}int{{ end }}>(this->{{ snakecase .FieldName }}));
    {{- else }}
    proto_msg.set_{{ .FieldName }}(this->{{ snakecase .FieldName }});
    {{- end }}
    {{- end }} // End IsRepeated
    {{- end }} // End Fields Loop

    std::string out = proto_msg.SerializeAsString();
    godot::PackedByteArray ret;
    ret.resize(out.size());
    memcpy(ret.ptrw(), out.data(), out.size());
    return ret;
}

// Deserialize
void {{ $className }}::from_byte_array(const godot::PackedByteArray &p_bytes) {
    {{- $cppNamespace := replace "." "::" $packageName }}
    {{ if $cppNamespace }}::{{ $cppNamespace }}::{{ else }}::{{ end }}{{ .MessageName }} proto_msg;
    if (!proto_msg.ParseFromArray(p_bytes.ptr(), p_bytes.size())) {
        godot::UtilityFunctions::printerr("Failed to parse {{ .MessageName }} from bytes");
        return;
    }

    // Clear Oneof fields first to avoid lingering pointers
    {{- range .Oneofs }}
    {{- range .Fields }}
    // Clear {{ .FieldName }} ({{ .GodotType }})
      {{- if .IsCustomType }}
    this->{{ snakecase .FieldName }} = nullptr;
      {{- else if eq .GodotType "godot::String" }}
    this->{{ snakecase .FieldName }} = "";
      {{- else if eq .GodotType "godot::PackedByteArray" }}
    this->{{ snakecase .FieldName }} = godot::PackedByteArray();
      {{- else }}
    this->{{ snakecase .FieldName }} = static_cast<{{ .GodotType }}>(0);
      {{- end }}
    {{- end }}
    this->{{ snakecase .Name }}_case = {{ toUpper (snakecase .Name) }}_NOT_SET;
    {{- end }}
    
    {{- range .Fields }}
    {{- if .IsRepeated }}
    // --- Repeated Field ---
    this->{{ snakecase .FieldName }}.clear();
    for (const auto& it : proto_msg.{{ .FieldName }}()) {
        {{- if .IsInnerCustomType }}
        {{ .InnerGodotType }}* wrapper = memnew({{ .InnerGodotType }});
        std::string child_data = it.SerializeAsString();
        godot::PackedByteArray child_bytes;
        child_bytes.resize(child_data.size());
        memcpy(child_bytes.ptrw(), child_data.data(), child_data.size());
        wrapper->from_byte_array(child_bytes);
        this->{{ snakecase .FieldName }}.push_back(wrapper);
        {{- else if eq .InnerGodotType "godot::String" }}
        this->{{ snakecase .FieldName }}.push_back(godot::String(it.c_str()));
        {{- else }}
        this->{{ snakecase .FieldName }}.push_back(it);
        {{- end }}
    }
    {{- else if .IsMap }}
    this->{{ snakecase .FieldName }}.clear();
    for (auto const& [key, val] : proto_msg.{{ .FieldName }}()) {
        godot::Variant k;
        {{- if eq .MapKeyGodotType "godot::String" }}
        k = godot::String(key.c_str());
        {{- else }}
        k = key;
        {{- end }}

        godot::Variant v;
        {{- if .MapValueIsCustom }}
        {{ .MapValueGodotType }}* wrapper = memnew({{ .MapValueGodotType }});
        std::string child_data = val.SerializeAsString();
        godot::PackedByteArray child_bytes;
        child_bytes.resize(child_data.size());
        memcpy(child_bytes.ptrw(), child_data.data(), child_data.size());
        wrapper->from_byte_array(child_bytes);
        v = wrapper;
        {{- else if eq .MapValueGodotType "godot::String" }}
        v = godot::String(val.c_str());
        {{- else }}
        v = val;
        {{- end }}

        this->{{ snakecase .FieldName }}[k] = v;
    }
    {{- else }}
    // --- Singular Field ---
    
    // --- Special WKT Handling ---
    {{- if eq .ProtoTypeName ".google.protobuf.Timestamp" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = GDBufUtils::timestamp_to_millis(proto_msg.{{ .FieldName }}());
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.Duration" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = proto_msg.{{ .FieldName }}().seconds();
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.StringValue" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = godot::String(proto_msg.{{ .FieldName }}().value().c_str());
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.Int32Value" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = proto_msg.{{ .FieldName }}().value();
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.BoolValue" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = proto_msg.{{ .FieldName }}().value();
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.Any" }}
    // TODO: Implement Any deserialization
    {{- else if eq .ProtoTypeName ".google.protobuf.Empty" }}
    // Empty: no-op
    {{- else if eq .ProtoTypeName ".google.protobuf.FieldMask" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }}.resize(proto_msg.{{ .FieldName }}().paths_size());
        for (int i = 0; i < proto_msg.{{ .FieldName }}().paths_size(); i++) {
            this->{{ snakecase .FieldName }}.set(i, godot::String(proto_msg.{{ .FieldName }}().paths(i).c_str()));
        }
    }
    
    // --- Standard Handling ---
    {{- else if eq .GodotType "godot::Dictionary" }}
    this->{{ snakecase .FieldName }}.clear();
    if (proto_msg.has_{{ .FieldName }}()) {
        GDBufUtils::struct_to_dictionary(proto_msg.{{ .FieldName }}(), this->{{ snakecase .FieldName }});
    }
    {{- else if eq .GodotType "godot::Variant" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        GDBufUtils::value_to_variant(proto_msg.{{ .FieldName }}(), this->{{ snakecase .FieldName }});
    }
    {{- else if eq .GodotType "godot::Array" }}
    this->{{ snakecase .FieldName }}.clear();
    if (proto_msg.has_{{ .FieldName }}()) {
        GDBufUtils::list_value_to_array(proto_msg.{{ .FieldName }}(), this->{{ snakecase .FieldName }});
    }

    // --- Handling Nested Custom Messages ---
    {{- else if .IsCustomType }}
    if (proto_msg.has_{{ .FieldName }}()) {
        if (this->{{ snakecase .FieldName }} == nullptr) {
             this->{{ snakecase .FieldName }} = memnew({{ .GodotType }}); 
        }
        std::string child_data = proto_msg.{{ .FieldName }}().SerializeAsString();
        godot::PackedByteArray child_bytes;
        child_bytes.resize(child_data.size());
        memcpy(child_bytes.ptrw(), child_data.data(), child_data.size());
        
        this->{{ snakecase .FieldName }}->from_byte_array(child_bytes);
    }

    // --- Handling Primitives with Conversion ---
    {{- else if eq .GodotType "godot::String" }}
    this->{{ snakecase .FieldName }} = godot::String(proto_msg.{{ .FieldName }}().c_str());
    {{- else if eq .GodotType "godot::PackedByteArray" }}
    {
        std::string s = proto_msg.{{ .FieldName }}();
        godot::PackedByteArray pba;
        pba.resize(s.size());
        memcpy(pba.ptrw(), s.data(), s.size());
        this->{{ snakecase .FieldName }} = pba;
    }
    {{- else }}
    this->{{ snakecase .FieldName }} = proto_msg.{{ .FieldName }}();
    {{- end }}
    {{- end }} // End IsRepeated
    {{- end }} // End Fields Loop
}

{{- range .Oneofs }}
{{ $className }}::{{ toPascalCase .Name }}Case {{ $className }}::get_{{ snakecase .Name }}_case() const {
    return this->{{ snakecase .Name }}_case;
}
{{- end }}

{{- range .Fields }}
  {{- $currentField := . }}
  {{- if .IsCustomType }}
{{ .GodotType }}* {{ $className }}::get_{{ snakecase .FieldName }}() {
  return {{ snakecase .FieldName }};
}

void {{ $className }}::set_{{ snakecase .FieldName }}({{ .GodotType }}* p_{{ snakecase .FieldName }}) {
  {{- if .OneofName }}
  {{- $oneofName := .OneofName }}
  if (p_{{ snakecase .FieldName }} != nullptr) {
      // Clear other fields in {{ $oneofName }}
      {{- range $msgIndex, $msg := $.Messages }}
      {{- if eq $msg.ClassName $className }}
      {{- range $oneofIndex, $oneof := $msg.Oneofs }}
      {{- if eq $oneof.Name $oneofName }}
      {{- range $fieldIndex, $field := $oneof.Fields }}
      {{- if ne $field.FieldName $currentField.FieldName }}
      // Clear {{ $field.FieldName }} ({{ $field.GodotType }})
        {{- if $field.IsCustomType }}
      this->{{ snakecase $field.FieldName }} = nullptr;
        {{- else if eq $field.GodotType "godot::String" }}
      this->{{ snakecase $field.FieldName }} = "";
        {{- else if eq $field.GodotType "godot::PackedByteArray" }}
      this->{{ snakecase $field.FieldName }} = godot::PackedByteArray();
        {{- else }}
      this->{{ snakecase $field.FieldName }} = static_cast<{{ $field.GodotType }}>(0);
        {{- end }}
      {{- end }}
      {{- end }}
      this->{{ snakecase $oneof.Name }}_case = k{{ toPascalCase $currentField.FieldName }};
      {{- end }}
      {{- end }}
      {{- end }}
      {{- end }}
  } else {
    // Setting to null might clear the oneof if it was the active one
    if (this->{{ snakecase .OneofName }}_case == k{{ toPascalCase .FieldName }}) {
       this->{{ snakecase .OneofName }}_case = {{ toUpper (snakecase .OneofName) }}_NOT_SET;
    }
  }
  {{- end }}
  this->{{ snakecase .FieldName }} = p_{{ snakecase .FieldName }};
}
  {{- else }}
{{ .GodotType }} {{ $className }}::get_{{ snakecase .FieldName }}() {
  return {{ snakecase .FieldName }};
}

void {{ $className }}::set_{{ snakecase .FieldName }}({{ .GodotType }} p_{{ snakecase .FieldName }}) {
    {{- if .OneofName }}
    {{- $oneofName := .OneofName }}
    // Clear other fields in {{ $oneofName }}
    {{- range $msgIndex, $msg := $.Messages }}
    {{- if eq $msg.ClassName $className }}
    {{- range $oneofIndex, $oneof := $msg.Oneofs }}
    {{- if eq $oneof.Name $oneofName }}
    {{- range $fieldIndex, $field := $oneof.Fields }}
    {{- if ne $field.FieldName $currentField.FieldName }}
    // Clear {{ $field.FieldName }} ({{ $field.GodotType }})
      {{- if $field.IsCustomType }}
    this->{{ snakecase $field.FieldName }} = nullptr;
      {{- else if eq $field.GodotType "godot::String" }}
    this->{{ snakecase $field.FieldName }} = "";
      {{- else if eq $field.GodotType "godot::PackedByteArray" }}
    this->{{ snakecase $field.FieldName }} = godot::PackedByteArray();
      {{- else }}
    this->{{ snakecase $field.FieldName }} = static_cast<{{ $field.GodotType }}>(0);
      {{- end }}
    {{- end }}
    {{- end }}
    this->{{ snakecase $oneof.Name }}_case = k{{ toPascalCase $currentField.FieldName }};
    {{- end }}
    {{- end }}
    {{- end }}
    {{- end }}
    {{- end }}
  this->{{ snakecase .FieldName }} = p_{{ snakecase .FieldName }};
}
  {{- end }}

{{- end }}
{{- end }}
}
}
