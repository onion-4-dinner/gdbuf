// THIS FILE IS GENERATED BY GDBUF. DO NOT EDIT UNLESS YOU KNOW WHAT YOU'RE DOING
{{- $protoPathNoExtension := trimSuffix ".proto" .ProtoPath }}
{{- $protoFileNameNoExtension := base $protoPathNoExtension }}
{{- $packageName := .PackageName }}
#include <string>
#include "{{ $protoFileNameNoExtension }}.h"
#include "{{ $protoFileNameNoExtension }}.pb.h"
#include <cstdint> // Required for int64_t
#include <godot_cpp/variant/string.hpp>
#include "messages.h" // Include the shared utils
{{- range .Dependencies }}
#include "{{ . }}"
{{- end }}


namespace gdbuf {
namespace {{ snakecase $protoFileNameNoExtension }} {
{{- range .Messages }}
{{- $className := .ClassName }}

void {{ $className }}::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &{{ $className }}::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &{{ $className }}::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &{{ $className }}::from_byte_array);
  {{- range .Fields }}
  godot::ClassDB::bind_method(godot::D_METHOD("get_{{ snakecase .FieldName }}"), &{{ $className }}::get_{{ snakecase .FieldName }});
  godot::ClassDB::bind_method(godot::D_METHOD("set_{{ snakecase .FieldName }}", "value"), &{{ $className }}::set_{{ snakecase .FieldName }});
  godot::ClassDB::add_property("{{ $className }}", godot::PropertyInfo({{ godotVariantType .GodotType .IsCustomType .IsEnum }}, "{{ snakecase .FieldName }}"
      {{- if .IsCustomType }}, godot::PROPERTY_HINT_RESOURCE_TYPE, "{{ .GodotClassName }}"{{- end }}
      ), "set_{{ snakecase .FieldName }}", "get_{{ snakecase .FieldName }}");
  {{- end }}
}

godot::String {{ $className }}::get_proto_file_name() {
  return godot::String("{{ $protoFileNameNoExtension }}");
}

// Serialize
godot::PackedByteArray {{ $className }}::to_byte_array() {
    {{- $cppNamespace := replace "." "::" $packageName }}
    {{ if $cppNamespace }}::{{ $cppNamespace }}::{{ else }}::{{ end }}{{ .MessageName }} proto_msg; 

    {{- range .Fields }}
    {{- if .IsRepeated }}
    // --- Repeated Field ---
    godot::Array {{ snakecase .FieldName }}_arr = this->{{ snakecase .FieldName }};
    for (int i = 0; i < {{ snakecase .FieldName }}_arr.size(); i++) {
        {{- if .IsInnerCustomType }}
        godot::Object* obj = {{ snakecase .FieldName }}_arr[i];
        {{ .InnerGodotType }}* wrapper = godot::Object::cast_to<{{ .InnerGodotType }}>(obj);
        if (wrapper) {
             godot::PackedByteArray child_bytes = wrapper->to_byte_array();
             proto_msg.add_{{ .FieldName }}()->ParseFromArray(child_bytes.ptr(), child_bytes.size());
        }
        {{- else if eq .InnerGodotType "godot::String" }}
        proto_msg.add_{{ .FieldName }}(((godot::String){{ snakecase .FieldName }}_arr[i]).utf8().get_data());
        {{- else if .IsEnum }}
        {{- $enumType := replace "." "::" (trimPrefix "." .ProtoTypeName) }}
        proto_msg.add_{{ .FieldName }}(static_cast<{{ if $enumType }}::{{ $enumType }}{{ else }}int{{ end }}>((int64_t){{ snakecase .FieldName }}_arr[i]));
        {{- else }}
        proto_msg.add_{{ .FieldName }}({{ snakecase .FieldName }}_arr[i]);
        {{- end }}
    }
    {{- else if .IsMap }}
    // --- Map Field ---
    godot::Dictionary {{ snakecase .FieldName }}_dict = this->{{ snakecase .FieldName }};
    godot::Array keys_{{ snakecase .FieldName }} = {{ snakecase .FieldName }}_dict.keys();
    for (int i = 0; i < keys_{{ snakecase .FieldName }}.size(); i++) {
        auto key_var = keys_{{ snakecase .FieldName }}[i];
        auto val_var = {{ snakecase .FieldName }}_dict[key_var];

        // Key
        {{- if eq .MapKeyGodotType "godot::String" }}
        std::string k = ((godot::String)key_var).utf8().get_data();
        {{- else }}
        auto k = ({{ .MapKeyGodotType }})key_var;
        {{- end }}

        // Value
        {{- if .MapValueIsCustom }}
        godot::Object* obj = val_var;
        {{ .MapValueGodotType }}* wrapper = godot::Object::cast_to<{{ .MapValueGodotType }}>(obj);
        if (wrapper) {
             godot::PackedByteArray child_bytes = wrapper->to_byte_array();
             (*proto_msg.mutable_{{ .FieldName }}())[k].ParseFromArray(child_bytes.ptr(), child_bytes.size());
        }
        {{- else if eq .MapValueGodotType "godot::String" }}
        (*proto_msg.mutable_{{ .FieldName }}())[k] = ((godot::String)val_var).utf8().get_data();
        {{- else }}
        (*proto_msg.mutable_{{ .FieldName }}())[k] = ({{ .MapValueGodotType }})val_var;
        {{- end }}
    }
    {{- else }}
    // --- Singular Field ---
    // --- Special WKT Handling ---
    {{- if eq .ProtoTypeName ".google.protobuf.Timestamp" }}
    GDBufUtils::millis_to_timestamp(this->{{ snakecase .FieldName }}, proto_msg.mutable_{{ .FieldName }}());
    {{- else if eq .ProtoTypeName ".google.protobuf.Duration" }}
    proto_msg.mutable_{{ .FieldName }}()->set_seconds((int64_t)this->{{ snakecase .FieldName }});
    {{- else if eq .ProtoTypeName ".google.protobuf.StringValue" }}
    proto_msg.mutable_{{ .FieldName }}()->set_value(this->{{ snakecase .FieldName }}.utf8().get_data());
    {{- else if eq .ProtoTypeName ".google.protobuf.Int32Value" }}
    proto_msg.mutable_{{ .FieldName }}()->set_value(this->{{ snakecase .FieldName }});
    {{- else if eq .ProtoTypeName ".google.protobuf.BoolValue" }}
    proto_msg.mutable_{{ .FieldName }}()->set_value(this->{{ snakecase .FieldName }});
    {{- else if eq .ProtoTypeName ".google.protobuf.Any" }}
    // TODO: Implement Any serialization
    {{- else if eq .ProtoTypeName ".google.protobuf.Empty" }}
    // Empty: no-op
    
    // --- Handling WKTs ---
    {{- else if eq .GodotType "godot::Dictionary" }} 
    if (this->{{ snakecase .FieldName }}.size() > 0) {
        GDBufUtils::dictionary_to_struct(this->{{ snakecase .FieldName }}, proto_msg.mutable_{{ .FieldName }}());
    }
    {{- else if eq .GodotType "godot::Variant" }}
    GDBufUtils::variant_to_value(this->{{ snakecase .FieldName }}, *proto_msg.mutable_{{ .FieldName }}());
    {{- else if eq .GodotType "godot::Array" }}
    GDBufUtils::array_to_list_value(this->{{ snakecase .FieldName }}, proto_msg.mutable_{{ .FieldName }}());

    // --- Handling Nested Custom Messages ---
    {{- else if .IsCustomType }}
    if (this->{{ snakecase .FieldName }} != nullptr) {
        godot::PackedByteArray child_bytes = this->{{ snakecase .FieldName }}->to_byte_array();
        proto_msg.mutable_{{ .FieldName }}()->ParseFromArray(child_bytes.ptr(), child_bytes.size());
    }

    // --- Handling Primitives with Conversion ---
    {{- else if eq .GodotType "godot::String" }}
    proto_msg.set_{{ .FieldName }}(this->{{ snakecase .FieldName }}.utf8().get_data());
    {{- else if eq .GodotType "godot::PackedByteArray" }}
    {
        godot::PackedByteArray pba = this->{{ snakecase .FieldName }};
        proto_msg.set_{{ .FieldName }}(std::string((const char*)pba.ptr(), pba.size()));
    }
    {{- else if .IsEnum }}
    {{- $enumType := replace "." "::" (trimPrefix "." .ProtoTypeName) }}
    proto_msg.set_{{ .FieldName }}(static_cast<{{ if $enumType }}::{{ $enumType }}{{ else }}int{{ end }}>(this->{{ snakecase .FieldName }}));
    {{- else }}
    proto_msg.set_{{ .FieldName }}(this->{{ snakecase .FieldName }});
    {{- end }}
    {{- end }} // End IsRepeated
    {{- end }} // End Fields Loop

    std::string out = proto_msg.SerializeAsString();
    godot::PackedByteArray ret;
    ret.resize(out.size());
    memcpy(ret.ptrw(), out.data(), out.size());
    return ret;
}

// Deserialize
void {{ $className }}::from_byte_array(const godot::PackedByteArray &p_bytes) {
    {{- $cppNamespace := replace "." "::" $packageName }}
    {{ if $cppNamespace }}::{{ $cppNamespace }}::{{ else }}::{{ end }}{{ .MessageName }} proto_msg;
    if (!proto_msg.ParseFromArray(p_bytes.ptr(), p_bytes.size())) {
        godot::UtilityFunctions::printerr("Failed to parse {{ .MessageName }} from bytes");
        return;
    }

    {{- range .Fields }}
    {{- if .IsRepeated }}
    // --- Repeated Field ---
    this->{{ snakecase .FieldName }}.clear();
    for (const auto& it : proto_msg.{{ .FieldName }}()) {
        {{- if .IsInnerCustomType }}
        {{ .InnerGodotType }}* wrapper = memnew({{ .InnerGodotType }});
        std::string child_data = it.SerializeAsString();
        godot::PackedByteArray child_bytes;
        child_bytes.resize(child_data.size());
        memcpy(child_bytes.ptrw(), child_data.data(), child_data.size());
        wrapper->from_byte_array(child_bytes);
        this->{{ snakecase .FieldName }}.push_back(wrapper);
        {{- else if eq .InnerGodotType "godot::String" }}
        this->{{ snakecase .FieldName }}.push_back(godot::String(it.c_str()));
        {{- else }}
        this->{{ snakecase .FieldName }}.push_back(it);
        {{- end }}
    }
    {{- else if .IsMap }}
    this->{{ snakecase .FieldName }}.clear();
    for (auto const& [key, val] : proto_msg.{{ .FieldName }}()) {
        godot::Variant k;
        {{- if eq .MapKeyGodotType "godot::String" }}
        k = godot::String(key.c_str());
        {{- else }}
        k = key;
        {{- end }}

        godot::Variant v;
        {{- if .MapValueIsCustom }}
        {{ .MapValueGodotType }}* wrapper = memnew({{ .MapValueGodotType }});
        std::string child_data = val.SerializeAsString();
        godot::PackedByteArray child_bytes;
        child_bytes.resize(child_data.size());
        memcpy(child_bytes.ptrw(), child_data.data(), child_data.size());
        wrapper->from_byte_array(child_bytes);
        v = wrapper;
        {{- else if eq .MapValueGodotType "godot::String" }}
        v = godot::String(val.c_str());
        {{- else }}
        v = val;
        {{- end }}

        this->{{ snakecase .FieldName }}[k] = v;
    }
    {{- else }}
    // --- Singular Field ---
    
    // --- Special WKT Handling ---
    {{- if eq .ProtoTypeName ".google.protobuf.Timestamp" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = GDBufUtils::timestamp_to_millis(proto_msg.{{ .FieldName }}());
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.Duration" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = proto_msg.{{ .FieldName }}().seconds();
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.StringValue" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = godot::String(proto_msg.{{ .FieldName }}().value().c_str());
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.Int32Value" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = proto_msg.{{ .FieldName }}().value();
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.BoolValue" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        this->{{ snakecase .FieldName }} = proto_msg.{{ .FieldName }}().value();
    }
    {{- else if eq .ProtoTypeName ".google.protobuf.Any" }}
    // TODO: Implement Any deserialization
    {{- else if eq .ProtoTypeName ".google.protobuf.Empty" }}
    // Empty: no-op
    
    // --- Standard Handling ---
    {{- else if eq .GodotType "godot::Dictionary" }}
    this->{{ snakecase .FieldName }}.clear();
    if (proto_msg.has_{{ .FieldName }}()) {
        GDBufUtils::struct_to_dictionary(proto_msg.{{ .FieldName }}(), this->{{ snakecase .FieldName }});
    }
    {{- else if eq .GodotType "godot::Variant" }}
    if (proto_msg.has_{{ .FieldName }}()) {
        GDBufUtils::value_to_variant(proto_msg.{{ .FieldName }}(), this->{{ snakecase .FieldName }});
    }
    {{- else if eq .GodotType "godot::Array" }}
    this->{{ snakecase .FieldName }}.clear();
    if (proto_msg.has_{{ .FieldName }}()) {
        GDBufUtils::list_value_to_array(proto_msg.{{ .FieldName }}(), this->{{ snakecase .FieldName }});
    }

    // --- Handling Nested Custom Messages ---
    {{- else if .IsCustomType }}
    if (proto_msg.has_{{ .FieldName }}()) {
        if (this->{{ snakecase .FieldName }} == nullptr) {
             this->{{ snakecase .FieldName }} = memnew({{ .GodotType }}); 
        }
        std::string child_data = proto_msg.{{ .FieldName }}().SerializeAsString();
        godot::PackedByteArray child_bytes;
        child_bytes.resize(child_data.size());
        memcpy(child_bytes.ptrw(), child_data.data(), child_data.size());
        
        this->{{ snakecase .FieldName }}->from_byte_array(child_bytes);
    }

    // --- Handling Primitives with Conversion ---
    {{- else if eq .GodotType "godot::String" }}
    this->{{ snakecase .FieldName }} = godot::String(proto_msg.{{ .FieldName }}().c_str());
    {{- else if eq .GodotType "godot::PackedByteArray" }}
    {
        std::string s = proto_msg.{{ .FieldName }}();
        godot::PackedByteArray pba;
        pba.resize(s.size());
        memcpy(pba.ptrw(), s.data(), s.size());
        this->{{ snakecase .FieldName }} = pba;
    }
    {{- else }}
    this->{{ snakecase .FieldName }} = proto_msg.{{ .FieldName }}();
    {{- end }}
    {{- end }} // End IsRepeated
    {{- end }} // End Fields Loop
}

{{- range .Fields }}
  {{- if .IsCustomType }}
{{ .GodotType }}* {{ $className }}::get_{{ snakecase .FieldName }}() {
  return {{ snakecase .FieldName }};
}

void {{ $className }}::set_{{ snakecase .FieldName }}({{ .GodotType }}* p_{{ snakecase .FieldName }}) {
  this->{{ snakecase .FieldName }} = p_{{ snakecase .FieldName }};
}
  {{- else }}
{{ .GodotType }} {{ $className }}::get_{{ snakecase .FieldName }}() {
  return {{ snakecase .FieldName }};
}

void {{ $className }}::set_{{ snakecase .FieldName }}({{ .GodotType }} p_{{ snakecase .FieldName }}) {
  this->{{ snakecase .FieldName }} = p_{{ snakecase .FieldName }};
}
  {{- end }}

{{- end }}
{{- end }}
}
}
