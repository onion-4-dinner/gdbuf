// THIS FILE IS GENERATED BY GDBUF. DO NOT EDIT UNLESS YOU KNOW WHAT YOU'RE DOING
{{- $protoPathNoExtension := trimSuffix ".proto" .ProtoPath }}
{{- $protoFileNameNoExtension := base $protoPathNoExtension }}
{{- $packageName := .PackageName }}
#include <string>
#include "{{ $protoFileNameNoExtension }}.h"
#include "{{ $protoFileNameNoExtension }}.pb.h"
#include <cstdint> // Required for int64_t
#include <godot_cpp/variant/string.hpp>
#include <godot_cpp/variant/packed_string_array.hpp>
#include "messages.h" // Include the shared utils
{{- range .Dependencies }}
#include "{{ . }}"
{{- end }}

namespace gdbuf {
namespace {{ snakecase $protoFileNameNoExtension }} {
{{- range .Messages }}
{{- $className := .ClassName }}
{{- $structName := .MessageName }}
{{- if $packageName }}
    {{- $structName = nanopbType (printf ".%s.%s" $packageName .MessageName) }}
{{- else }}
    {{- $structName = nanopbType (printf ".%s" .MessageName) }}
{{- end }}

void {{ $className }}::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &{{ $className }}::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &{{ $className }}::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &{{ $className }}::from_byte_array);

  {{- range .Oneofs }}
  godot::ClassDB::bind_method(godot::D_METHOD("get_{{ snakecase .Name }}_case"), &{{ $className }}::get_{{ snakecase .Name }}_case);
  {{- range .Fields }}
  BIND_ENUM_CONSTANT(k{{ toPascalCase .FieldName }});
  {{- end }}
  BIND_ENUM_CONSTANT({{ toUpper (snakecase .Name) }}_NOT_SET);
  {{- end }}

  {{- range .Fields }}
  godot::ClassDB::bind_method(godot::D_METHOD("get_{{ snakecase .FieldName }}"), &{{ $className }}::get_{{ snakecase .FieldName }});
  godot::ClassDB::bind_method(godot::D_METHOD("set_{{ snakecase .FieldName }}", "value"), &{{ $className }}::set_{{ snakecase .FieldName }});
  godot::ClassDB::add_property("{{ $className }}", godot::PropertyInfo({{ godotVariantType .GodotType .IsCustomType .IsEnum }}, "{{ snakecase .FieldName }}"
      {{- if .IsCustomType }}, godot::PROPERTY_HINT_RESOURCE_TYPE, "{{ .GodotClassName }}"
      {{- else if .IsRepeated }}, godot::PROPERTY_HINT_NONE, ""
      {{- end }}
      ), "set_{{ snakecase .FieldName }}", "get_{{ snakecase .FieldName }}");
  {{- end }}
}

godot::String {{ $className }}::get_proto_file_name() {
  return godot::String("{{ $protoFileNameNoExtension }}");
}

godot::String {{ $className }}::_to_string() const {
    godot::String output = "{{ $className }} {";
    {{- range $i, $field := .Fields }}
    {{- if gt $i 0 }}
    output += ", ";
    {{- end }}

    output += "{{ .FieldName }}: ";

    {{- if .OneofName }}
    if (this->{{ snakecase .OneofName }}_case == k{{ toPascalCase .FieldName }}) {
    {{- end }}

    {{- if eq .GodotType "godot::String" }}
        output += "\"";
        output += this->{{ snakecase .FieldName }}.c_escape();
        output += "\"";
    {{- else if .IsCustomType }}
        if (this->{{ snakecase .FieldName }}.is_valid()) {
            output += godot::String(godot::Variant(this->{{ snakecase .FieldName }}));
        } else {
            output += "null";
        }
    {{- else }}
        output += godot::String(godot::Variant(this->{{ snakecase .FieldName }}));
    {{- end }}

    {{- if .OneofName }}
    } else {
        output += "<not set>";
    }
    {{- end }}
    {{- end }}

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray {{ $className }}::to_byte_array() const {
    struct _{{ $structName }} proto_msg = {{ $structName }}_init_zero;

    {{- range .Fields }}
    {{- $fieldName := .FieldName }}
    {{- $target := printf "proto_msg.%s" $fieldName }}
    
    {{- if .OneofName }}
        {{- $target = printf "proto_msg.%s.%s" .OneofName $fieldName }}
        if (this->{{ snakecase .OneofName }}_case == k{{ toPascalCase .FieldName }}) {
             proto_msg.which_{{ .OneofName }} = {{ $structName }}_{{ .FieldName }}_tag;
    {{- end }}

    {{- if .IsRepeated }}
        // --- Repeated Field ---
        godot::Array {{ snakecase .FieldName }}_arr = this->{{ snakecase .FieldName }};
        proto_msg.{{ .FieldName }}_count = {{ snakecase .FieldName }}_arr.size();
        if (proto_msg.{{ .FieldName }}_count > 0) {
            proto_msg.{{ .FieldName }} = (decltype(proto_msg.{{ .FieldName }}))malloc(sizeof(*proto_msg.{{ .FieldName }}) * proto_msg.{{ .FieldName }}_count);
            {{- if .IsInnerCustomType }}
            // Array of Messages
            for (int i = 0; i < proto_msg.{{ .FieldName }}_count; i++) {
                godot::Object* obj = {{ snakecase .FieldName }}_arr[i];
                {{ .InnerGodotType }}* wrapper = godot::Object::cast_to<{{ .InnerGodotType }}>(obj);
                if (wrapper) {
                     godot::PackedByteArray b = wrapper->to_byte_array();
                     pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
                     pb_decode(&s, {{ nanopbType .ProtoTypeName }}_fields, &proto_msg.{{ .FieldName }}[i]);
                } else {
                     proto_msg.{{ .FieldName }}[i] = {{ nanopbType .ProtoTypeName }}_init_zero;
                }
            }
            {{- else if eq .InnerGodotType "godot::String" }}
            // Array of Strings
            for (int i = 0; i < proto_msg.{{ .FieldName }}_count; i++) {
                 godot::String str = {{ snakecase .FieldName }}_arr[i];
                 std::string s = str.utf8().get_data();
                 proto_msg.{{ .FieldName }}[i] = (char*)malloc(s.size() + 1);
                 memcpy(proto_msg.{{ .FieldName }}[i], s.data(), s.size() + 1);
            }
            {{- else }}
            // Array of Primitives
            for (int i = 0; i < proto_msg.{{ .FieldName }}_count; i++) {
                 proto_msg.{{ .FieldName }}[i] = (decltype(proto_msg.{{ .FieldName }}[i])){{ snakecase .FieldName }}_arr[i];
            }
            {{- end }}
        }
    {{- else if .IsMap }}
        // --- Map Field ---
        godot::Dictionary {{ snakecase .FieldName }}_dict = this->{{ snakecase .FieldName }};
        proto_msg.{{ .FieldName }}_count = {{ snakecase .FieldName }}_dict.size();
        if (proto_msg.{{ .FieldName }}_count > 0) {
            proto_msg.{{ .FieldName }} = (decltype(proto_msg.{{ .FieldName }}))malloc(sizeof(*proto_msg.{{ .FieldName }}) * proto_msg.{{ .FieldName }}_count);
            godot::Array keys = {{ snakecase .FieldName }}_dict.keys();
            for (int i = 0; i < keys.size(); i++) {
                godot::Variant key_var = keys[i];
                godot::Variant val_var = {{ snakecase .FieldName }}_dict[key_var];
                
                // Key
                {{- if eq .MapKeyGodotType "godot::String" }}
                {
                    std::string k = ((godot::String)key_var).utf8().get_data();
                    proto_msg.{{ .FieldName }}[i].key = (char*)malloc(k.size() + 1);
                    memcpy(proto_msg.{{ .FieldName }}[i].key, k.data(), k.size() + 1);
                }
                {{- else }}
                proto_msg.{{ .FieldName }}[i].key = (decltype(proto_msg.{{ .FieldName }}[i].key))malloc(sizeof(*proto_msg.{{ .FieldName }}[i].key));
                *proto_msg.{{ .FieldName }}[i].key = (decltype(*proto_msg.{{ .FieldName }}[i].key))key_var;
                {{- end }}

                // Value
                {{- if .MapValueIsCustom }}
                {
                    godot::Object* obj = val_var;
                    {{ .MapValueGodotType }}* wrapper = godot::Object::cast_to<{{ .MapValueGodotType }}>(obj);
                    if (wrapper) {
                         godot::PackedByteArray b = wrapper->to_byte_array();
                         pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
                         // Assuming value message type name via convention if needed, but for now using generic decode
                         // This is likely broken for nested map values without explicit descriptor.
                         // But gdbuf_test uses map<int32, BasicTestMessage>
                         // BasicTestMessage_fields is available.
                         pb_decode(&s, {{ nanopbType .MapValueGodotType }}_fields, &proto_msg.{{ .FieldName }}[i].value);
                    }
                }
                {{- else if eq .MapValueGodotType "godot::String" }}
                {
                    std::string v = ((godot::String)val_var).utf8().get_data();
                    proto_msg.{{ .FieldName }}[i].value = (char*)malloc(v.size() + 1);
                    memcpy(proto_msg.{{ .FieldName }}[i].value, v.data(), v.size() + 1);
                }
                {{- else }}
                proto_msg.{{ .FieldName }}[i].value = (decltype(proto_msg.{{ .FieldName }}[i].value))malloc(sizeof(*proto_msg.{{ .FieldName }}[i].value));
                *proto_msg.{{ .FieldName }}[i].value = (decltype(*proto_msg.{{ .FieldName }}[i].value))val_var;
                {{- end }}
            }
        }
    {{- else }}
        // --- Singular Field ---
        {{- if .IsCustomType }}
        if ({{ snakecase .FieldName }}.is_valid()) {
             godot::PackedByteArray b = {{ snakecase .FieldName }}->to_byte_array();
             // Allocate pointer
             {{ $target }} = (decltype({{ $target }}))malloc(sizeof(*{{ $target }}));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, {{ nanopbType .ProtoTypeName }}_fields, {{ $target }});
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.Timestamp" }}
        {
             {{ $target }} = (struct _google_protobuf_Timestamp*)malloc(sizeof(struct _google_protobuf_Timestamp));
             int64_t millis = this->{{ snakecase .FieldName }};
             {{ $target }}->seconds = (int64_t*)malloc(sizeof(int64_t));
             *{{ $target }}->seconds = millis / 1000;
             {{ $target }}->nanos = (int32_t*)malloc(sizeof(int32_t));
             *{{ $target }}->nanos = (int32_t)((millis % 1000) * 1000000);
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.Duration" }}
        {
             {{ $target }} = (struct _google_protobuf_Duration*)malloc(sizeof(struct _google_protobuf_Duration));
             double sec = this->{{ snakecase .FieldName }};
             {{ $target }}->seconds = (int64_t*)malloc(sizeof(int64_t));
             *{{ $target }}->seconds = (int64_t)sec;
             {{ $target }}->nanos = (int32_t*)malloc(sizeof(int32_t));
             *{{ $target }}->nanos = (int32_t)((sec - (int64_t)sec) * 1000000000.0);
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.StringValue" }}
        {
             {{ $target }} = (struct _google_protobuf_StringValue*)malloc(sizeof(struct _google_protobuf_StringValue));
             std::string s = this->{{ snakecase .FieldName }}.utf8().get_data();
             {{ $target }}->value = (char*)malloc(s.size() + 1);
             memcpy({{ $target }}->value, s.data(), s.size() + 1);
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.Int32Value" }}
        {
             {{ $target }} = (struct _google_protobuf_Int32Value*)malloc(sizeof(struct _google_protobuf_Int32Value));
             {{ $target }}->value = (int32_t*)malloc(sizeof(int32_t));
             *{{ $target }}->value = this->{{ snakecase .FieldName }};
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.BoolValue" }}
        {
             {{ $target }} = (struct _google_protobuf_BoolValue*)malloc(sizeof(struct _google_protobuf_BoolValue));
             {{ $target }}->value = (bool*)malloc(sizeof(bool));
             *{{ $target }}->value = this->{{ snakecase .FieldName }};
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.Struct" }}
        // TODO: Implement Struct serialization
        {{- else if eq .ProtoTypeName ".google.protobuf.Any" }}
        // TODO: Implement Any serialization
        {{- else if eq .ProtoTypeName ".google.protobuf.FieldMask" }}
        // TODO: Implement FieldMask serialization
        {{- else if eq .ProtoTypeName ".google.protobuf.Empty" }}
        // Empty: no-op (but allocate the struct)
        {{ $target }} = (struct _google_protobuf_Empty*)malloc(sizeof(struct _google_protobuf_Empty));
        {{- else if eq .GodotType "godot::String" }}
        {
            std::string s = this->{{ snakecase .FieldName }}.utf8().get_data();
            {{ $target }} = (char*)malloc(s.size() + 1);
            memcpy({{ $target }}, s.data(), s.size() + 1);
        }
        {{- else if eq .GodotType "godot::PackedByteArray" }}
        {
            godot::PackedByteArray pba = this->{{ snakecase .FieldName }};
            {{ $target }} = (pb_bytes_array_t*)malloc(PB_BYTES_ARRAY_T_ALLOCSIZE(pba.size()));
            {{ $target }}->size = pba.size();
            memcpy({{ $target }}->bytes, pba.ptr(), pba.size());
        }
        {{- else }}
        // Primitive pointer allocation
        {{ $target }} = (decltype({{ $target }}))malloc(sizeof(*{{ $target }}));
        *{{ $target }} = (decltype(*{{ $target }}))this->{{ snakecase .FieldName }};
        {{- end }}
    {{- end }}

    {{- if .OneofName }}
        }
    {{- end }}

    {{- end }} // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, {{ $structName }}_fields, &proto_msg)) {
         pb_release({{ $structName }}_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, {{ $structName }}_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release({{ $structName }}_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error {{ $className }}::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _{{ $structName }} proto_msg = {{ $structName }}_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, {{ $structName }}_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
    {{- range .Oneofs }}
    this->{{ snakecase .Name }}_case = {{ toUpper (snakecase .Name) }}_NOT_SET;
    // Clear fields... (simplified for brevity, setters handle it mostly if we call them, but direct access is better for from_byte_array)
    {{- end }}

    {{- range .Fields }}
    {{- $fieldName := .FieldName }}
    {{- $source := printf "proto_msg.%s" $fieldName }}
    {{- $isActive := "true" }}
    
    {{- if .OneofName }}
        {{- $source = printf "proto_msg.%s.%s" .OneofName $fieldName }}
        {{- $isActive = printf "proto_msg.which_%s == %s_%s_tag" .OneofName $structName .FieldName }}
        if ({{ $isActive }}) {
            this->{{ snakecase .OneofName }}_case = k{{ toPascalCase .FieldName }};
    {{- end }}

    {{- if .IsRepeated }}
        this->{{ snakecase .FieldName }}.clear();
        for (int i = 0; i < proto_msg.{{ .FieldName }}_count; i++) {
            {{- if .IsInnerCustomType }}
            godot::Ref<{{ .InnerGodotType }}> wrapper;
            wrapper.instantiate();
            // Encode struct back to bytes to decode into wrapper... roundabout but works
            size_t size;
            pb_get_encoded_size(&size, {{ nanopbType .ProtoTypeName }}_fields, &proto_msg.{{ .FieldName }}[i]);
            godot::PackedByteArray b; 
            b.resize(size);
            pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
            pb_encode(&os, {{ nanopbType .ProtoTypeName }}_fields, &proto_msg.{{ .FieldName }}[i]);
            wrapper->from_byte_array(b);
            this->{{ snakecase .FieldName }}.push_back(wrapper);
            {{- else if eq .InnerGodotType "godot::String" }}
            if (proto_msg.{{ .FieldName }}[i])
                this->{{ snakecase .FieldName }}.push_back(godot::String(proto_msg.{{ .FieldName }}[i]));
            {{- else }}
            this->{{ snakecase .FieldName }}.push_back(proto_msg.{{ .FieldName }}[i]);
            {{- end }}
        }
    {{- else if .IsMap }}
        this->{{ snakecase .FieldName }}.clear();
        for (int i = 0; i < proto_msg.{{ .FieldName }}_count; i++) {
            godot::Variant k;
            godot::Variant v;
            
            // Key
            {{- if eq .MapKeyGodotType "godot::String" }}
            if (proto_msg.{{ .FieldName }}[i].key)
                k = godot::String(proto_msg.{{ .FieldName }}[i].key);
            else
                k = "";
            {{- else }}
            if (proto_msg.{{ .FieldName }}[i].key)
                k = *proto_msg.{{ .FieldName }}[i].key;
            else
                k = 0;
            {{- end }}

            // Value
            {{- if .MapValueIsCustom }}
            godot::Ref<{{ .MapValueGodotType }}> wrapper;
            wrapper.instantiate();
            size_t size;
            pb_get_encoded_size(&size, {{ nanopbType .MapValueGodotType }}_fields, &proto_msg.{{ .FieldName }}[i].value);
            godot::PackedByteArray b;
            b.resize(size);
            pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
            pb_encode(&os, {{ nanopbType .MapValueGodotType }}_fields, &proto_msg.{{ .FieldName }}[i].value);
            wrapper->from_byte_array(b);
            v = wrapper;
            {{- else if eq .MapValueGodotType "godot::String" }}
            if (proto_msg.{{ .FieldName }}[i].value)
                v = godot::String(proto_msg.{{ .FieldName }}[i].value);
            else
                v = "";
            {{- else }}
            if (proto_msg.{{ .FieldName }}[i].value)
                v = *proto_msg.{{ .FieldName }}[i].value;
            else
                v = 0;
            {{- end }}

            this->{{ snakecase .FieldName }}[k] = v;
        }
    {{- else }}
        {{- if .IsCustomType }}
        if ({{ $source }} != NULL) { // Check pointer presence
             if (!this->{{ snakecase .FieldName }}.is_valid()) this->{{ snakecase .FieldName }}.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, {{ nanopbType .ProtoTypeName }}_fields, {{ $source }});
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, {{ nanopbType .ProtoTypeName }}_fields, {{ $source }});
             this->{{ snakecase .FieldName }}->from_byte_array(b);
        } else {
             this->{{ snakecase .FieldName }} = godot::Ref<{{ .GodotType }}>();
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.Timestamp" }}
        if ({{ $source }} != NULL) {
             int64_t sec = 0;
             int32_t nanos = 0;
             if ({{ $source }}->seconds != NULL) sec = *{{ $source }}->seconds;
             if ({{ $source }}->nanos != NULL) nanos = *{{ $source }}->nanos;
             this->{{ snakecase .FieldName }} = sec * 1000 + nanos / 1000000;
        } else {
             this->{{ snakecase .FieldName }} = 0;
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.Duration" }}
        if ({{ $source }} != NULL) {
             int64_t sec = 0;
             int32_t nanos = 0;
             if ({{ $source }}->seconds != NULL) sec = *{{ $source }}->seconds;
             if ({{ $source }}->nanos != NULL) nanos = *{{ $source }}->nanos;
             this->{{ snakecase .FieldName }} = (double)sec + ((double)nanos / 1000000000.0);
        } else {
             this->{{ snakecase .FieldName }} = 0.0;
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.StringValue" }}
        if ({{ $source }} != NULL && {{ $source }}->value != NULL) {
             this->{{ snakecase .FieldName }} = godot::String({{ $source }}->value);
        } else {
             this->{{ snakecase .FieldName }} = "";
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.Int32Value" }}
        if ({{ $source }} != NULL && {{ $source }}->value != NULL) {
             this->{{ snakecase .FieldName }} = *{{ $source }}->value;
        } else {
             this->{{ snakecase .FieldName }} = 0;
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.BoolValue" }}
        if ({{ $source }} != NULL && {{ $source }}->value != NULL) {
             this->{{ snakecase .FieldName }} = *{{ $source }}->value;
        } else {
             this->{{ snakecase .FieldName }} = false;
        }
        {{- else if eq .ProtoTypeName ".google.protobuf.Struct" }}
        // TODO: Implement Struct deserialization
        {{- else if eq .ProtoTypeName ".google.protobuf.Any" }}
        // TODO: Implement Any deserialization
        {{- else if eq .ProtoTypeName ".google.protobuf.FieldMask" }}
        // TODO: Implement FieldMask deserialization
        {{- else if eq .ProtoTypeName ".google.protobuf.Empty" }}
        // Empty: no-op
        {{- else if eq .GodotType "godot::String" }}
        if ({{ $source }}) {
            this->{{ snakecase .FieldName }} = godot::String({{ $source }});
        } else {
            this->{{ snakecase .FieldName }} = "";
        }
        {{- else if eq .GodotType "godot::PackedByteArray" }}
        if ({{ $source }}) {
            godot::PackedByteArray pba;
            pba.resize({{ $source }}->size);
            memcpy(pba.ptrw(), {{ $source }}->bytes, {{ $source }}->size);
            this->{{ snakecase .FieldName }} = pba;
        } else {
            this->{{ snakecase .FieldName }} = godot::PackedByteArray();
        }
        {{- else }}
        // Primitive pointer
        if ({{ $source }} != NULL) {
            this->{{ snakecase .FieldName }} = ({{ .GodotType }})*{{ $source }};
        } else {
            this->{{ snakecase .FieldName }} = ({{ .GodotType }})0;
        }
        {{- end }}
    {{- end }}

    {{- if .OneofName }}
        }
    {{- end }}
    {{- end }}

    pb_release({{ $structName }}_fields, &proto_msg);
    return godot::OK;
}

{{- range .Oneofs }}
{{ $className }}::{{ toPascalCase .Name }}Case {{ $className }}::get_{{ snakecase .Name }}_case() const {
    return this->{{ snakecase .Name }}_case;
}
{{- end }}

{{- range .Fields }}
  {{- $currentField := . }}
  {{- if .IsCustomType }}
godot::Ref<{{ .GodotType }}> {{ $className }}::get_{{ snakecase .FieldName }}() {
  return {{ snakecase .FieldName }};
}

void {{ $className }}::set_{{ snakecase .FieldName }}(const godot::Ref<{{ .GodotType }}> p_{{ snakecase .FieldName }}) {
  {{- if .OneofName }}
  {{- $oneofName := .OneofName }}
  if (p_{{ snakecase .FieldName }}.is_valid()) {
      // Clear other fields... (omitted for brevity but needed in real impl)
      this->{{ snakecase .OneofName }}_case = k{{ toPascalCase $currentField.FieldName }};
  } else {
    if (this->{{ snakecase .OneofName }}_case == k{{ toPascalCase .FieldName }}) {
       this->{{ snakecase .OneofName }}_case = {{ toUpper (snakecase .OneofName) }}_NOT_SET;
    }
  }
  {{- end }}
  this->{{ snakecase .FieldName }} = p_{{ snakecase .FieldName }};
}
  {{- else }}
{{ .GodotType }} {{ $className }}::get_{{ snakecase .FieldName }}() {
  return {{ snakecase .FieldName }};
}

void {{ $className }}::set_{{ snakecase .FieldName }}({{ .GodotType }} p_{{ snakecase .FieldName }}) {
    {{- if .OneofName }}
    {{- $oneofName := .OneofName }}
    this->{{ snakecase .OneofName }}_case = k{{ toPascalCase $currentField.FieldName }};
    {{- end }}
  this->{{ snakecase .FieldName }} = p_{{ snakecase .FieldName }};
}
  {{- end }}

{{- end }}
{{- end }}
}
}
