// THIS FILE IS GENERATED BY GDBUF. DO NOT EDIT UNLESS YOU KNOW WHAT YOU'RE DOING
#include <string>
#include "dependency.h"
#include "dependency.pb.h"
#include <cstdint> // Required for int64_t
#include <type_traits> // Required for std::decay_t
#include <godot_cpp/variant/string.hpp>
#include <godot_cpp/variant/packed_string_array.hpp>
#include "messages.h" // Include the shared utils

namespace gdbuf {
namespace dependency {

void DependencyMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &DependencyMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &DependencyMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &DependencyMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_name"), &DependencyMessage::get_name);
  godot::ClassDB::bind_method(godot::D_METHOD("set_name", "value"), &DependencyMessage::set_name);
  godot::ClassDB::add_property("DependencyMessage", godot::PropertyInfo(godot::Variant::STRING, "name"
      ), "set_name", "get_name");
}

godot::String DependencyMessage::get_proto_file_name() {
  return godot::String("dependency");
}

godot::String DependencyMessage::_to_string() const {
    godot::String output = "DependencyMessage {";

    output += "name: ";
        output += "\"";
        output += this->name.c_escape();
        output += "\"";

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray DependencyMessage::to_byte_array() const {
    struct _dependency_DependencyMessage proto_msg = dependency_DependencyMessage_init_zero;
        // --- Singular Field ---
        {
            std::string s = this->name.utf8().get_data();
            proto_msg.name = (char*)malloc(s.size() + 1);
            memcpy(proto_msg.name, s.data(), s.size() + 1);
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, dependency_DependencyMessage_fields, &proto_msg)) {
         pb_release(dependency_DependencyMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, dependency_DependencyMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(dependency_DependencyMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error DependencyMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _dependency_DependencyMessage proto_msg = dependency_DependencyMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, dependency_DependencyMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
        if (proto_msg.name) {
            this->name = godot::String(proto_msg.name);
        } else {
            this->name = "";
        }

    pb_release(dependency_DependencyMessage_fields, &proto_msg);
    return godot::OK;
}
godot::String DependencyMessage::get_name() {
  return name;
}

void DependencyMessage::set_name(godot::String p_name) {
  this->name = p_name;
}
}
}
