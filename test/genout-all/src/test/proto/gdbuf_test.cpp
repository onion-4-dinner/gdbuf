// THIS FILE IS GENERATED BY GDBUF. DO NOT EDIT UNLESS YOU KNOW WHAT YOU'RE DOING
#include <string>
#include "gdbuf_test.h"
#include "gdbuf_test.pb.h"
#include <cstdint> // Required for int64_t
#include <type_traits> // Required for std::decay_t
#include <godot_cpp/variant/string.hpp>
#include <godot_cpp/variant/packed_string_array.hpp>
#include "messages.h" // Include the shared utils
#include "test/proto/dependency.h"
#include "test/proto/nested/deeply/nested.h"

namespace gdbuf {
namespace gdbuf_test {

void BasicTestMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &BasicTestMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &BasicTestMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &BasicTestMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_double_field"), &BasicTestMessage::get_double_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_double_field", "value"), &BasicTestMessage::set_double_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::FLOAT, "double_field"
      ), "set_double_field", "get_double_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_float_field"), &BasicTestMessage::get_float_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_float_field", "value"), &BasicTestMessage::set_float_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::FLOAT, "float_field"
      ), "set_float_field", "get_float_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_int32_field"), &BasicTestMessage::get_int32_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_int32_field", "value"), &BasicTestMessage::set_int32_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "int32_field"
      ), "set_int32_field", "get_int32_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_int64_field"), &BasicTestMessage::get_int64_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_int64_field", "value"), &BasicTestMessage::set_int64_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "int64_field"
      ), "set_int64_field", "get_int64_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_uint32_field"), &BasicTestMessage::get_uint32_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_uint32_field", "value"), &BasicTestMessage::set_uint32_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "uint32_field"
      ), "set_uint32_field", "get_uint32_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_uint64_field"), &BasicTestMessage::get_uint64_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_uint64_field", "value"), &BasicTestMessage::set_uint64_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "uint64_field"
      ), "set_uint64_field", "get_uint64_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_sint32_field"), &BasicTestMessage::get_sint32_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_sint32_field", "value"), &BasicTestMessage::set_sint32_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "sint32_field"
      ), "set_sint32_field", "get_sint32_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_sint64_field"), &BasicTestMessage::get_sint64_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_sint64_field", "value"), &BasicTestMessage::set_sint64_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "sint64_field"
      ), "set_sint64_field", "get_sint64_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_fixed32_field"), &BasicTestMessage::get_fixed32_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_fixed32_field", "value"), &BasicTestMessage::set_fixed32_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "fixed32_field"
      ), "set_fixed32_field", "get_fixed32_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_fixed64_field"), &BasicTestMessage::get_fixed64_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_fixed64_field", "value"), &BasicTestMessage::set_fixed64_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "fixed64_field"
      ), "set_fixed64_field", "get_fixed64_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_sfixed32_field"), &BasicTestMessage::get_sfixed32_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_sfixed32_field", "value"), &BasicTestMessage::set_sfixed32_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "sfixed32_field"
      ), "set_sfixed32_field", "get_sfixed32_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_sfixed64_field"), &BasicTestMessage::get_sfixed64_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_sfixed64_field", "value"), &BasicTestMessage::set_sfixed64_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::INT, "sfixed64_field"
      ), "set_sfixed64_field", "get_sfixed64_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_bool_field"), &BasicTestMessage::get_bool_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_bool_field", "value"), &BasicTestMessage::set_bool_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::BOOL, "bool_field"
      ), "set_bool_field", "get_bool_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_string_field"), &BasicTestMessage::get_string_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_string_field", "value"), &BasicTestMessage::set_string_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::STRING, "string_field"
      ), "set_string_field", "get_string_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_bytes_field"), &BasicTestMessage::get_bytes_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_bytes_field", "value"), &BasicTestMessage::set_bytes_field);
  godot::ClassDB::add_property("BasicTestMessage", godot::PropertyInfo(godot::Variant::PACKED_BYTE_ARRAY, "bytes_field"
      ), "set_bytes_field", "get_bytes_field");
}

godot::String BasicTestMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String BasicTestMessage::_to_string() const {
    godot::String output = "BasicTestMessage {";

    output += "double_field: ";
        output += godot::String(godot::Variant(this->double_field));
    output += ", ";

    output += "float_field: ";
        output += godot::String(godot::Variant(this->float_field));
    output += ", ";

    output += "int32_field: ";
        output += godot::String(godot::Variant(this->int32_field));
    output += ", ";

    output += "int64_field: ";
        output += godot::String(godot::Variant(this->int64_field));
    output += ", ";

    output += "uint32_field: ";
        output += godot::String(godot::Variant(this->uint32_field));
    output += ", ";

    output += "uint64_field: ";
        output += godot::String(godot::Variant(this->uint64_field));
    output += ", ";

    output += "sint32_field: ";
        output += godot::String(godot::Variant(this->sint32_field));
    output += ", ";

    output += "sint64_field: ";
        output += godot::String(godot::Variant(this->sint64_field));
    output += ", ";

    output += "fixed32_field: ";
        output += godot::String(godot::Variant(this->fixed32_field));
    output += ", ";

    output += "fixed64_field: ";
        output += godot::String(godot::Variant(this->fixed64_field));
    output += ", ";

    output += "sfixed32_field: ";
        output += godot::String(godot::Variant(this->sfixed32_field));
    output += ", ";

    output += "sfixed64_field: ";
        output += godot::String(godot::Variant(this->sfixed64_field));
    output += ", ";

    output += "bool_field: ";
        output += godot::String(godot::Variant(this->bool_field));
    output += ", ";

    output += "string_field: ";
        output += "\"";
        output += this->string_field.c_escape();
        output += "\"";
    output += ", ";

    output += "bytes_field: ";
        output += godot::String(godot::Variant(this->bytes_field));

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray BasicTestMessage::to_byte_array() const {
    struct _BasicTestMessage proto_msg = BasicTestMessage_init_zero;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.double_field = (decltype(proto_msg.double_field))malloc(sizeof(*proto_msg.double_field));
        *proto_msg.double_field = (decltype(*proto_msg.double_field))this->double_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.float_field = (decltype(proto_msg.float_field))malloc(sizeof(*proto_msg.float_field));
        *proto_msg.float_field = (decltype(*proto_msg.float_field))this->float_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.int32_field = (decltype(proto_msg.int32_field))malloc(sizeof(*proto_msg.int32_field));
        *proto_msg.int32_field = (decltype(*proto_msg.int32_field))this->int32_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.int64_field = (decltype(proto_msg.int64_field))malloc(sizeof(*proto_msg.int64_field));
        *proto_msg.int64_field = (decltype(*proto_msg.int64_field))this->int64_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.uint32_field = (decltype(proto_msg.uint32_field))malloc(sizeof(*proto_msg.uint32_field));
        *proto_msg.uint32_field = (decltype(*proto_msg.uint32_field))this->uint32_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.uint64_field = (decltype(proto_msg.uint64_field))malloc(sizeof(*proto_msg.uint64_field));
        *proto_msg.uint64_field = (decltype(*proto_msg.uint64_field))this->uint64_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.sint32_field = (decltype(proto_msg.sint32_field))malloc(sizeof(*proto_msg.sint32_field));
        *proto_msg.sint32_field = (decltype(*proto_msg.sint32_field))this->sint32_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.sint64_field = (decltype(proto_msg.sint64_field))malloc(sizeof(*proto_msg.sint64_field));
        *proto_msg.sint64_field = (decltype(*proto_msg.sint64_field))this->sint64_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.fixed32_field = (decltype(proto_msg.fixed32_field))malloc(sizeof(*proto_msg.fixed32_field));
        *proto_msg.fixed32_field = (decltype(*proto_msg.fixed32_field))this->fixed32_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.fixed64_field = (decltype(proto_msg.fixed64_field))malloc(sizeof(*proto_msg.fixed64_field));
        *proto_msg.fixed64_field = (decltype(*proto_msg.fixed64_field))this->fixed64_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.sfixed32_field = (decltype(proto_msg.sfixed32_field))malloc(sizeof(*proto_msg.sfixed32_field));
        *proto_msg.sfixed32_field = (decltype(*proto_msg.sfixed32_field))this->sfixed32_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.sfixed64_field = (decltype(proto_msg.sfixed64_field))malloc(sizeof(*proto_msg.sfixed64_field));
        *proto_msg.sfixed64_field = (decltype(*proto_msg.sfixed64_field))this->sfixed64_field;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.bool_field = (decltype(proto_msg.bool_field))malloc(sizeof(*proto_msg.bool_field));
        *proto_msg.bool_field = (decltype(*proto_msg.bool_field))this->bool_field;
        // --- Singular Field ---
        {
            std::string s = this->string_field.utf8().get_data();
            proto_msg.string_field = (char*)malloc(s.size() + 1);
            memcpy(proto_msg.string_field, s.data(), s.size() + 1);
        }
        // --- Singular Field ---
        {
            godot::PackedByteArray pba = this->bytes_field;
            proto_msg.bytes_field = (pb_bytes_array_t*)malloc(PB_BYTES_ARRAY_T_ALLOCSIZE(pba.size()));
            proto_msg.bytes_field->size = pba.size();
            memcpy(proto_msg.bytes_field->bytes, pba.ptr(), pba.size());
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, BasicTestMessage_fields, &proto_msg)) {
         pb_release(BasicTestMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, BasicTestMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(BasicTestMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error BasicTestMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _BasicTestMessage proto_msg = BasicTestMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, BasicTestMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
        // Primitive pointer
        if (proto_msg.double_field != NULL) {
            this->double_field = (double)*proto_msg.double_field;
        } else {
            this->double_field = (double)0;
        }
        // Primitive pointer
        if (proto_msg.float_field != NULL) {
            this->float_field = (float)*proto_msg.float_field;
        } else {
            this->float_field = (float)0;
        }
        // Primitive pointer
        if (proto_msg.int32_field != NULL) {
            this->int32_field = (int32_t)*proto_msg.int32_field;
        } else {
            this->int32_field = (int32_t)0;
        }
        // Primitive pointer
        if (proto_msg.int64_field != NULL) {
            this->int64_field = (int64_t)*proto_msg.int64_field;
        } else {
            this->int64_field = (int64_t)0;
        }
        // Primitive pointer
        if (proto_msg.uint32_field != NULL) {
            this->uint32_field = (uint32_t)*proto_msg.uint32_field;
        } else {
            this->uint32_field = (uint32_t)0;
        }
        // Primitive pointer
        if (proto_msg.uint64_field != NULL) {
            this->uint64_field = (uint64_t)*proto_msg.uint64_field;
        } else {
            this->uint64_field = (uint64_t)0;
        }
        // Primitive pointer
        if (proto_msg.sint32_field != NULL) {
            this->sint32_field = (int32_t)*proto_msg.sint32_field;
        } else {
            this->sint32_field = (int32_t)0;
        }
        // Primitive pointer
        if (proto_msg.sint64_field != NULL) {
            this->sint64_field = (int64_t)*proto_msg.sint64_field;
        } else {
            this->sint64_field = (int64_t)0;
        }
        // Primitive pointer
        if (proto_msg.fixed32_field != NULL) {
            this->fixed32_field = (int32_t)*proto_msg.fixed32_field;
        } else {
            this->fixed32_field = (int32_t)0;
        }
        // Primitive pointer
        if (proto_msg.fixed64_field != NULL) {
            this->fixed64_field = (int64_t)*proto_msg.fixed64_field;
        } else {
            this->fixed64_field = (int64_t)0;
        }
        // Primitive pointer
        if (proto_msg.sfixed32_field != NULL) {
            this->sfixed32_field = (int32_t)*proto_msg.sfixed32_field;
        } else {
            this->sfixed32_field = (int32_t)0;
        }
        // Primitive pointer
        if (proto_msg.sfixed64_field != NULL) {
            this->sfixed64_field = (int64_t)*proto_msg.sfixed64_field;
        } else {
            this->sfixed64_field = (int64_t)0;
        }
        // Primitive pointer
        if (proto_msg.bool_field != NULL) {
            this->bool_field = (bool)*proto_msg.bool_field;
        } else {
            this->bool_field = (bool)0;
        }
        if (proto_msg.string_field) {
            this->string_field = godot::String(proto_msg.string_field);
        } else {
            this->string_field = "";
        }
        if (proto_msg.bytes_field) {
            godot::PackedByteArray pba;
            pba.resize(proto_msg.bytes_field->size);
            memcpy(pba.ptrw(), proto_msg.bytes_field->bytes, proto_msg.bytes_field->size);
            this->bytes_field = pba;
        } else {
            this->bytes_field = godot::PackedByteArray();
        }

    pb_release(BasicTestMessage_fields, &proto_msg);
    return godot::OK;
}
double BasicTestMessage::get_double_field() {
  return double_field;
}

void BasicTestMessage::set_double_field(double p_double_field) {
  this->double_field = p_double_field;
}
float BasicTestMessage::get_float_field() {
  return float_field;
}

void BasicTestMessage::set_float_field(float p_float_field) {
  this->float_field = p_float_field;
}
int32_t BasicTestMessage::get_int32_field() {
  return int32_field;
}

void BasicTestMessage::set_int32_field(int32_t p_int32_field) {
  this->int32_field = p_int32_field;
}
int64_t BasicTestMessage::get_int64_field() {
  return int64_field;
}

void BasicTestMessage::set_int64_field(int64_t p_int64_field) {
  this->int64_field = p_int64_field;
}
uint32_t BasicTestMessage::get_uint32_field() {
  return uint32_field;
}

void BasicTestMessage::set_uint32_field(uint32_t p_uint32_field) {
  this->uint32_field = p_uint32_field;
}
uint64_t BasicTestMessage::get_uint64_field() {
  return uint64_field;
}

void BasicTestMessage::set_uint64_field(uint64_t p_uint64_field) {
  this->uint64_field = p_uint64_field;
}
int32_t BasicTestMessage::get_sint32_field() {
  return sint32_field;
}

void BasicTestMessage::set_sint32_field(int32_t p_sint32_field) {
  this->sint32_field = p_sint32_field;
}
int64_t BasicTestMessage::get_sint64_field() {
  return sint64_field;
}

void BasicTestMessage::set_sint64_field(int64_t p_sint64_field) {
  this->sint64_field = p_sint64_field;
}
int32_t BasicTestMessage::get_fixed32_field() {
  return fixed32_field;
}

void BasicTestMessage::set_fixed32_field(int32_t p_fixed32_field) {
  this->fixed32_field = p_fixed32_field;
}
int64_t BasicTestMessage::get_fixed64_field() {
  return fixed64_field;
}

void BasicTestMessage::set_fixed64_field(int64_t p_fixed64_field) {
  this->fixed64_field = p_fixed64_field;
}
int32_t BasicTestMessage::get_sfixed32_field() {
  return sfixed32_field;
}

void BasicTestMessage::set_sfixed32_field(int32_t p_sfixed32_field) {
  this->sfixed32_field = p_sfixed32_field;
}
int64_t BasicTestMessage::get_sfixed64_field() {
  return sfixed64_field;
}

void BasicTestMessage::set_sfixed64_field(int64_t p_sfixed64_field) {
  this->sfixed64_field = p_sfixed64_field;
}
bool BasicTestMessage::get_bool_field() {
  return bool_field;
}

void BasicTestMessage::set_bool_field(bool p_bool_field) {
  this->bool_field = p_bool_field;
}
godot::String BasicTestMessage::get_string_field() {
  return string_field;
}

void BasicTestMessage::set_string_field(godot::String p_string_field) {
  this->string_field = p_string_field;
}
godot::PackedByteArray BasicTestMessage::get_bytes_field() {
  return bytes_field;
}

void BasicTestMessage::set_bytes_field(godot::PackedByteArray p_bytes_field) {
  this->bytes_field = p_bytes_field;
}

void SpecialFieldTypesMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &SpecialFieldTypesMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &SpecialFieldTypesMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &SpecialFieldTypesMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get__optional_string_case"), &SpecialFieldTypesMessage::get__optional_string_case);
  BIND_ENUM_CONSTANT(_OPTIONAL_STRING_NOT_SET);
  godot::ClassDB::bind_method(godot::D_METHOD("get_optional_string"), &SpecialFieldTypesMessage::get_optional_string);
  godot::ClassDB::bind_method(godot::D_METHOD("set_optional_string", "value"), &SpecialFieldTypesMessage::set_optional_string);
  godot::ClassDB::add_property("SpecialFieldTypesMessage", godot::PropertyInfo(godot::Variant::STRING, "optional_string"
      ), "set_optional_string", "get_optional_string");
  godot::ClassDB::bind_method(godot::D_METHOD("get_repeated_int32"), &SpecialFieldTypesMessage::get_repeated_int32);
  godot::ClassDB::bind_method(godot::D_METHOD("set_repeated_int32", "value"), &SpecialFieldTypesMessage::set_repeated_int32);
  godot::ClassDB::add_property("SpecialFieldTypesMessage", godot::PropertyInfo(godot::Variant::ARRAY, "repeated_int32", godot::PROPERTY_HINT_NONE, ""
      ), "set_repeated_int32", "get_repeated_int32");
  godot::ClassDB::bind_method(godot::D_METHOD("get_repeated_packed_double"), &SpecialFieldTypesMessage::get_repeated_packed_double);
  godot::ClassDB::bind_method(godot::D_METHOD("set_repeated_packed_double", "value"), &SpecialFieldTypesMessage::set_repeated_packed_double);
  godot::ClassDB::add_property("SpecialFieldTypesMessage", godot::PropertyInfo(godot::Variant::ARRAY, "repeated_packed_double", godot::PROPERTY_HINT_NONE, ""
      ), "set_repeated_packed_double", "get_repeated_packed_double");
}

godot::String SpecialFieldTypesMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String SpecialFieldTypesMessage::_to_string() const {
    godot::String output = "SpecialFieldTypesMessage {";

    output += "optional_string: ";
        output += "\"";
        output += this->optional_string.c_escape();
        output += "\"";
    output += ", ";

    output += "repeated_int32: ";
        output += godot::String(godot::Variant(this->repeated_int32));
    output += ", ";

    output += "repeated_packed_double: ";
        output += godot::String(godot::Variant(this->repeated_packed_double));

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray SpecialFieldTypesMessage::to_byte_array() const {
    struct _SpecialFieldTypesMessage proto_msg = SpecialFieldTypesMessage_init_zero;
        // --- Singular Field ---
        {
            std::string s = this->optional_string.utf8().get_data();
            proto_msg.optional_string = (char*)malloc(s.size() + 1);
            memcpy(proto_msg.optional_string, s.data(), s.size() + 1);
        }
        // --- Repeated Field ---
        godot::Array repeated_int32_arr = this->repeated_int32;
        proto_msg.repeated_int32_count = repeated_int32_arr.size();
        if (proto_msg.repeated_int32_count > 0) {
            proto_msg.repeated_int32 = (decltype(proto_msg.repeated_int32))malloc(sizeof(*proto_msg.repeated_int32) * proto_msg.repeated_int32_count);
            // Array of Primitives
            for (int i = 0; i < proto_msg.repeated_int32_count; i++) {
                 proto_msg.repeated_int32[i] = (std::decay_t<decltype(proto_msg.repeated_int32[i])>)repeated_int32_arr[i];
            }
        }
        // --- Repeated Field ---
        godot::Array repeated_packed_double_arr = this->repeated_packed_double;
        proto_msg.repeated_packed_double_count = repeated_packed_double_arr.size();
        if (proto_msg.repeated_packed_double_count > 0) {
            proto_msg.repeated_packed_double = (decltype(proto_msg.repeated_packed_double))malloc(sizeof(*proto_msg.repeated_packed_double) * proto_msg.repeated_packed_double_count);
            // Array of Primitives
            for (int i = 0; i < proto_msg.repeated_packed_double_count; i++) {
                 proto_msg.repeated_packed_double[i] = (std::decay_t<decltype(proto_msg.repeated_packed_double[i])>)repeated_packed_double_arr[i];
            }
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, SpecialFieldTypesMessage_fields, &proto_msg)) {
         pb_release(SpecialFieldTypesMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, SpecialFieldTypesMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(SpecialFieldTypesMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error SpecialFieldTypesMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _SpecialFieldTypesMessage proto_msg = SpecialFieldTypesMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, SpecialFieldTypesMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
    this->_optional_string_case = _OPTIONAL_STRING_NOT_SET;
    // Clear fields... (simplified for brevity, setters handle it mostly if we call them, but direct access is better for from_byte_array)
        if (proto_msg.optional_string) {
            this->optional_string = godot::String(proto_msg.optional_string);
        } else {
            this->optional_string = "";
        }
        this->repeated_int32.clear();
        for (int i = 0; i < proto_msg.repeated_int32_count; i++) {
            this->repeated_int32.push_back(proto_msg.repeated_int32[i]);
        }
        this->repeated_packed_double.clear();
        for (int i = 0; i < proto_msg.repeated_packed_double_count; i++) {
            this->repeated_packed_double.push_back(proto_msg.repeated_packed_double[i]);
        }

    pb_release(SpecialFieldTypesMessage_fields, &proto_msg);
    return godot::OK;
}
SpecialFieldTypesMessage::OptionalStringCase SpecialFieldTypesMessage::get__optional_string_case() const {
    return this->_optional_string_case;
}
godot::String SpecialFieldTypesMessage::get_optional_string() {
  return optional_string;
}

void SpecialFieldTypesMessage::set_optional_string(godot::String p_optional_string) {
  this->optional_string = p_optional_string;
}
godot::Array SpecialFieldTypesMessage::get_repeated_int32() {
  return repeated_int32;
}

void SpecialFieldTypesMessage::set_repeated_int32(godot::Array p_repeated_int32) {
  this->repeated_int32 = p_repeated_int32;
}
godot::Array SpecialFieldTypesMessage::get_repeated_packed_double() {
  return repeated_packed_double;
}

void SpecialFieldTypesMessage::set_repeated_packed_double(godot::Array p_repeated_packed_double) {
  this->repeated_packed_double = p_repeated_packed_double;
}

void OneOfMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &OneOfMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &OneOfMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &OneOfMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_test_oneof_case"), &OneOfMessage::get_test_oneof_case);
  BIND_ENUM_CONSTANT(kStringField);
  BIND_ENUM_CONSTANT(kInt32Field);
  BIND_ENUM_CONSTANT(kMessageField);
  BIND_ENUM_CONSTANT(TEST_ONEOF_NOT_SET);
  godot::ClassDB::bind_method(godot::D_METHOD("get_string_field"), &OneOfMessage::get_string_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_string_field", "value"), &OneOfMessage::set_string_field);
  godot::ClassDB::add_property("OneOfMessage", godot::PropertyInfo(godot::Variant::STRING, "string_field"
      ), "set_string_field", "get_string_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_int32_field"), &OneOfMessage::get_int32_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_int32_field", "value"), &OneOfMessage::set_int32_field);
  godot::ClassDB::add_property("OneOfMessage", godot::PropertyInfo(godot::Variant::INT, "int32_field"
      ), "set_int32_field", "get_int32_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_message_field"), &OneOfMessage::get_message_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_message_field", "value"), &OneOfMessage::set_message_field);
  godot::ClassDB::add_property("OneOfMessage", godot::PropertyInfo(godot::Variant::OBJECT, "message_field", godot::PROPERTY_HINT_RESOURCE_TYPE, "BasicTestMessage"
      ), "set_message_field", "get_message_field");
}

godot::String OneOfMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String OneOfMessage::_to_string() const {
    godot::String output = "OneOfMessage {";

    output += "string_field: ";
    if (this->test_oneof_case == kStringField) {
        output += "\"";
        output += this->string_field.c_escape();
        output += "\"";
    } else {
        output += "<not set>";
    }
    output += ", ";

    output += "int32_field: ";
    if (this->test_oneof_case == kInt32Field) {
        output += godot::String(godot::Variant(this->int32_field));
    } else {
        output += "<not set>";
    }
    output += ", ";

    output += "message_field: ";
    if (this->test_oneof_case == kMessageField) {
        if (this->message_field.is_valid()) {
            output += godot::String(godot::Variant(this->message_field));
        } else {
            output += "null";
        }
    } else {
        output += "<not set>";
    }

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray OneOfMessage::to_byte_array() const {
    struct _OneOfMessage proto_msg = OneOfMessage_init_zero;
        if (this->test_oneof_case == kStringField) {
             proto_msg.which_test_oneof = OneOfMessage_string_field_tag;
        // --- Singular Field ---
        {
            std::string s = this->string_field.utf8().get_data();
            proto_msg.test_oneof.string_field = (char*)malloc(s.size() + 1);
            memcpy(proto_msg.test_oneof.string_field, s.data(), s.size() + 1);
        }
        }
        if (this->test_oneof_case == kInt32Field) {
             proto_msg.which_test_oneof = OneOfMessage_int32_field_tag;
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.test_oneof.int32_field = (decltype(proto_msg.test_oneof.int32_field))malloc(sizeof(*proto_msg.test_oneof.int32_field));
        *proto_msg.test_oneof.int32_field = (decltype(*proto_msg.test_oneof.int32_field))this->int32_field;
        }
        if (this->test_oneof_case == kMessageField) {
             proto_msg.which_test_oneof = OneOfMessage_message_field_tag;
        // --- Singular Field ---
        if (message_field.is_valid()) {
             godot::PackedByteArray b = message_field->to_byte_array();
             // Allocate pointer
             proto_msg.test_oneof.message_field = (decltype(proto_msg.test_oneof.message_field))malloc(sizeof(*proto_msg.test_oneof.message_field));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, BasicTestMessage_fields, proto_msg.test_oneof.message_field);
        }
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, OneOfMessage_fields, &proto_msg)) {
         pb_release(OneOfMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, OneOfMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(OneOfMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error OneOfMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _OneOfMessage proto_msg = OneOfMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, OneOfMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
    this->test_oneof_case = TEST_ONEOF_NOT_SET;
    // Clear fields... (simplified for brevity, setters handle it mostly if we call them, but direct access is better for from_byte_array)
        if (proto_msg.which_test_oneof == OneOfMessage_string_field_tag) {
            this->test_oneof_case = kStringField;
        if (proto_msg.test_oneof.string_field) {
            this->string_field = godot::String(proto_msg.test_oneof.string_field);
        } else {
            this->string_field = "";
        }
        }
        if (proto_msg.which_test_oneof == OneOfMessage_int32_field_tag) {
            this->test_oneof_case = kInt32Field;
        // Primitive pointer
        if (proto_msg.test_oneof.int32_field != NULL) {
            this->int32_field = (int32_t)*proto_msg.test_oneof.int32_field;
        } else {
            this->int32_field = (int32_t)0;
        }
        }
        if (proto_msg.which_test_oneof == OneOfMessage_message_field_tag) {
            this->test_oneof_case = kMessageField;
        if (proto_msg.test_oneof.message_field != NULL) { // Check pointer presence
             if (!this->message_field.is_valid()) this->message_field.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, BasicTestMessage_fields, proto_msg.test_oneof.message_field);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, BasicTestMessage_fields, proto_msg.test_oneof.message_field);
             this->message_field->from_byte_array(b);
        } else {
             this->message_field = godot::Ref<BasicTestMessage>();
        }
        }

    pb_release(OneOfMessage_fields, &proto_msg);
    return godot::OK;
}
OneOfMessage::TestOneofCase OneOfMessage::get_test_oneof_case() const {
    return this->test_oneof_case;
}
godot::String OneOfMessage::get_string_field() {
  return string_field;
}

void OneOfMessage::set_string_field(godot::String p_string_field) {
    this->test_oneof_case = kStringField;
  this->string_field = p_string_field;
}
int32_t OneOfMessage::get_int32_field() {
  return int32_field;
}

void OneOfMessage::set_int32_field(int32_t p_int32_field) {
    this->test_oneof_case = kInt32Field;
  this->int32_field = p_int32_field;
}
godot::Ref<BasicTestMessage> OneOfMessage::get_message_field() {
  return message_field;
}

void OneOfMessage::set_message_field(const godot::Ref<BasicTestMessage> p_message_field) {
  if (p_message_field.is_valid()) {
      // Clear other fields... (omitted for brevity but needed in real impl)
      this->test_oneof_case = kMessageField;
  } else {
    if (this->test_oneof_case == kMessageField) {
       this->test_oneof_case = TEST_ONEOF_NOT_SET;
    }
  }
  this->message_field = p_message_field;
}

void GoogleWellKnownTypesMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &GoogleWellKnownTypesMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &GoogleWellKnownTypesMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &GoogleWellKnownTypesMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_any_field"), &GoogleWellKnownTypesMessage::get_any_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_any_field", "value"), &GoogleWellKnownTypesMessage::set_any_field);
  godot::ClassDB::add_property("GoogleWellKnownTypesMessage", godot::PropertyInfo(godot::Variant::DICTIONARY, "any_field"
      ), "set_any_field", "get_any_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_timestamp_field"), &GoogleWellKnownTypesMessage::get_timestamp_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_timestamp_field", "value"), &GoogleWellKnownTypesMessage::set_timestamp_field);
  godot::ClassDB::add_property("GoogleWellKnownTypesMessage", godot::PropertyInfo(godot::Variant::INT, "timestamp_field"
      ), "set_timestamp_field", "get_timestamp_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_duration_field"), &GoogleWellKnownTypesMessage::get_duration_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_duration_field", "value"), &GoogleWellKnownTypesMessage::set_duration_field);
  godot::ClassDB::add_property("GoogleWellKnownTypesMessage", godot::PropertyInfo(godot::Variant::FLOAT, "duration_field"
      ), "set_duration_field", "get_duration_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_string_wrapper"), &GoogleWellKnownTypesMessage::get_string_wrapper);
  godot::ClassDB::bind_method(godot::D_METHOD("set_string_wrapper", "value"), &GoogleWellKnownTypesMessage::set_string_wrapper);
  godot::ClassDB::add_property("GoogleWellKnownTypesMessage", godot::PropertyInfo(godot::Variant::STRING, "string_wrapper"
      ), "set_string_wrapper", "get_string_wrapper");
  godot::ClassDB::bind_method(godot::D_METHOD("get_int32_wrapper"), &GoogleWellKnownTypesMessage::get_int32_wrapper);
  godot::ClassDB::bind_method(godot::D_METHOD("set_int32_wrapper", "value"), &GoogleWellKnownTypesMessage::set_int32_wrapper);
  godot::ClassDB::add_property("GoogleWellKnownTypesMessage", godot::PropertyInfo(godot::Variant::INT, "int32_wrapper"
      ), "set_int32_wrapper", "get_int32_wrapper");
  godot::ClassDB::bind_method(godot::D_METHOD("get_struct_field"), &GoogleWellKnownTypesMessage::get_struct_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_struct_field", "value"), &GoogleWellKnownTypesMessage::set_struct_field);
  godot::ClassDB::add_property("GoogleWellKnownTypesMessage", godot::PropertyInfo(godot::Variant::DICTIONARY, "struct_field"
      ), "set_struct_field", "get_struct_field");
  godot::ClassDB::bind_method(godot::D_METHOD("get_empty_field"), &GoogleWellKnownTypesMessage::get_empty_field);
  godot::ClassDB::bind_method(godot::D_METHOD("set_empty_field", "value"), &GoogleWellKnownTypesMessage::set_empty_field);
  godot::ClassDB::add_property("GoogleWellKnownTypesMessage", godot::PropertyInfo(godot::Variant::NIL, "empty_field"
      ), "set_empty_field", "get_empty_field");
}

godot::String GoogleWellKnownTypesMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String GoogleWellKnownTypesMessage::_to_string() const {
    godot::String output = "GoogleWellKnownTypesMessage {";

    output += "any_field: ";
        output += godot::String(godot::Variant(this->any_field));
    output += ", ";

    output += "timestamp_field: ";
        output += godot::String(godot::Variant(this->timestamp_field));
    output += ", ";

    output += "duration_field: ";
        output += godot::String(godot::Variant(this->duration_field));
    output += ", ";

    output += "string_wrapper: ";
        output += "\"";
        output += this->string_wrapper.c_escape();
        output += "\"";
    output += ", ";

    output += "int32_wrapper: ";
        output += godot::String(godot::Variant(this->int32_wrapper));
    output += ", ";

    output += "struct_field: ";
        output += godot::String(godot::Variant(this->struct_field));
    output += ", ";

    output += "empty_field: ";
        output += godot::String(godot::Variant(this->empty_field));

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray GoogleWellKnownTypesMessage::to_byte_array() const {
    struct _GoogleWellKnownTypesMessage proto_msg = GoogleWellKnownTypesMessage_init_zero;
        // --- Singular Field ---
        // TODO: Implement Any serialization
        // --- Singular Field ---
        {
             proto_msg.timestamp_field = (struct _google_protobuf_Timestamp*)malloc(sizeof(struct _google_protobuf_Timestamp));
             int64_t millis = this->timestamp_field;
             proto_msg.timestamp_field->seconds = (int64_t*)malloc(sizeof(int64_t));
             *proto_msg.timestamp_field->seconds = millis / 1000;
             proto_msg.timestamp_field->nanos = (int32_t*)malloc(sizeof(int32_t));
             *proto_msg.timestamp_field->nanos = (int32_t)((millis % 1000) * 1000000);
        }
        // --- Singular Field ---
        {
             proto_msg.duration_field = (struct _google_protobuf_Duration*)malloc(sizeof(struct _google_protobuf_Duration));
             double sec = this->duration_field;
             proto_msg.duration_field->seconds = (int64_t*)malloc(sizeof(int64_t));
             *proto_msg.duration_field->seconds = (int64_t)sec;
             proto_msg.duration_field->nanos = (int32_t*)malloc(sizeof(int32_t));
             *proto_msg.duration_field->nanos = (int32_t)((sec - (int64_t)sec) * 1000000000.0);
        }
        // --- Singular Field ---
        {
             proto_msg.string_wrapper = (struct _google_protobuf_StringValue*)malloc(sizeof(struct _google_protobuf_StringValue));
             std::string s = this->string_wrapper.utf8().get_data();
             proto_msg.string_wrapper->value = (char*)malloc(s.size() + 1);
             memcpy(proto_msg.string_wrapper->value, s.data(), s.size() + 1);
        }
        // --- Singular Field ---
        {
             proto_msg.int32_wrapper = (struct _google_protobuf_Int32Value*)malloc(sizeof(struct _google_protobuf_Int32Value));
             proto_msg.int32_wrapper->value = (int32_t*)malloc(sizeof(int32_t));
             *proto_msg.int32_wrapper->value = this->int32_wrapper;
        }
        // --- Singular Field ---
        // TODO: Implement Struct serialization
        // --- Singular Field ---
        // Empty: no-op (but allocate the struct)
        proto_msg.empty_field = (struct _google_protobuf_Empty*)malloc(sizeof(struct _google_protobuf_Empty)); // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, GoogleWellKnownTypesMessage_fields, &proto_msg)) {
         pb_release(GoogleWellKnownTypesMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, GoogleWellKnownTypesMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(GoogleWellKnownTypesMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error GoogleWellKnownTypesMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _GoogleWellKnownTypesMessage proto_msg = GoogleWellKnownTypesMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, GoogleWellKnownTypesMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
        // TODO: Implement Any deserialization
        if (proto_msg.timestamp_field != NULL) {
             int64_t sec = 0;
             int32_t nanos = 0;
             if (proto_msg.timestamp_field->seconds != NULL) sec = *proto_msg.timestamp_field->seconds;
             if (proto_msg.timestamp_field->nanos != NULL) nanos = *proto_msg.timestamp_field->nanos;
             this->timestamp_field = sec * 1000 + nanos / 1000000;
        } else {
             this->timestamp_field = 0;
        }
        if (proto_msg.duration_field != NULL) {
             int64_t sec = 0;
             int32_t nanos = 0;
             if (proto_msg.duration_field->seconds != NULL) sec = *proto_msg.duration_field->seconds;
             if (proto_msg.duration_field->nanos != NULL) nanos = *proto_msg.duration_field->nanos;
             this->duration_field = (double)sec + ((double)nanos / 1000000000.0);
        } else {
             this->duration_field = 0.0;
        }
        if (proto_msg.string_wrapper != NULL && proto_msg.string_wrapper->value != NULL) {
             this->string_wrapper = godot::String(proto_msg.string_wrapper->value);
        } else {
             this->string_wrapper = "";
        }
        if (proto_msg.int32_wrapper != NULL && proto_msg.int32_wrapper->value != NULL) {
             this->int32_wrapper = *proto_msg.int32_wrapper->value;
        } else {
             this->int32_wrapper = 0;
        }
        // TODO: Implement Struct deserialization
        // Empty: no-op

    pb_release(GoogleWellKnownTypesMessage_fields, &proto_msg);
    return godot::OK;
}
godot::Dictionary GoogleWellKnownTypesMessage::get_any_field() {
  return any_field;
}

void GoogleWellKnownTypesMessage::set_any_field(godot::Dictionary p_any_field) {
  this->any_field = p_any_field;
}
int64_t GoogleWellKnownTypesMessage::get_timestamp_field() {
  return timestamp_field;
}

void GoogleWellKnownTypesMessage::set_timestamp_field(int64_t p_timestamp_field) {
  this->timestamp_field = p_timestamp_field;
}
double GoogleWellKnownTypesMessage::get_duration_field() {
  return duration_field;
}

void GoogleWellKnownTypesMessage::set_duration_field(double p_duration_field) {
  this->duration_field = p_duration_field;
}
godot::String GoogleWellKnownTypesMessage::get_string_wrapper() {
  return string_wrapper;
}

void GoogleWellKnownTypesMessage::set_string_wrapper(godot::String p_string_wrapper) {
  this->string_wrapper = p_string_wrapper;
}
int32_t GoogleWellKnownTypesMessage::get_int32_wrapper() {
  return int32_wrapper;
}

void GoogleWellKnownTypesMessage::set_int32_wrapper(int32_t p_int32_wrapper) {
  this->int32_wrapper = p_int32_wrapper;
}
godot::Dictionary GoogleWellKnownTypesMessage::get_struct_field() {
  return struct_field;
}

void GoogleWellKnownTypesMessage::set_struct_field(godot::Dictionary p_struct_field) {
  this->struct_field = p_struct_field;
}
godot::Variant GoogleWellKnownTypesMessage::get_empty_field() {
  return empty_field;
}

void GoogleWellKnownTypesMessage::set_empty_field(godot::Variant p_empty_field) {
  this->empty_field = p_empty_field;
}

void MapMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &MapMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &MapMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &MapMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_string_int_map"), &MapMessage::get_string_int_map);
  godot::ClassDB::bind_method(godot::D_METHOD("set_string_int_map", "value"), &MapMessage::set_string_int_map);
  godot::ClassDB::add_property("MapMessage", godot::PropertyInfo(godot::Variant::DICTIONARY, "string_int_map"
      ), "set_string_int_map", "get_string_int_map");
  godot::ClassDB::bind_method(godot::D_METHOD("get_int_msg_map"), &MapMessage::get_int_msg_map);
  godot::ClassDB::bind_method(godot::D_METHOD("set_int_msg_map", "value"), &MapMessage::set_int_msg_map);
  godot::ClassDB::add_property("MapMessage", godot::PropertyInfo(godot::Variant::DICTIONARY, "int_msg_map"
      ), "set_int_msg_map", "get_int_msg_map");
  godot::ClassDB::bind_method(godot::D_METHOD("get_string_string_map"), &MapMessage::get_string_string_map);
  godot::ClassDB::bind_method(godot::D_METHOD("set_string_string_map", "value"), &MapMessage::set_string_string_map);
  godot::ClassDB::add_property("MapMessage", godot::PropertyInfo(godot::Variant::DICTIONARY, "string_string_map"
      ), "set_string_string_map", "get_string_string_map");
}

godot::String MapMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String MapMessage::_to_string() const {
    godot::String output = "MapMessage {";

    output += "string_int_map: ";
        output += godot::String(godot::Variant(this->string_int_map));
    output += ", ";

    output += "int_msg_map: ";
        output += godot::String(godot::Variant(this->int_msg_map));
    output += ", ";

    output += "string_string_map: ";
        output += godot::String(godot::Variant(this->string_string_map));

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray MapMessage::to_byte_array() const {
    struct _MapMessage proto_msg = MapMessage_init_zero;
        // --- Map Field ---
        godot::Dictionary string_int_map_dict = this->string_int_map;
        proto_msg.string_int_map_count = string_int_map_dict.size();
        if (proto_msg.string_int_map_count > 0) {
            proto_msg.string_int_map = (decltype(proto_msg.string_int_map))malloc(sizeof(*proto_msg.string_int_map) * proto_msg.string_int_map_count);
            godot::Array keys = string_int_map_dict.keys();
            for (int i = 0; i < keys.size(); i++) {
                godot::Variant key_var = keys[i];
                godot::Variant val_var = string_int_map_dict[key_var];
                
                // Key
                {
                    std::string k = ((godot::String)key_var).utf8().get_data();
                    proto_msg.string_int_map[i].key = (char*)malloc(k.size() + 1);
                    memcpy(proto_msg.string_int_map[i].key, k.data(), k.size() + 1);
                }

                // Value
                proto_msg.string_int_map[i].value = (decltype(proto_msg.string_int_map[i].value))malloc(sizeof(*proto_msg.string_int_map[i].value));
                *proto_msg.string_int_map[i].value = (std::decay_t<decltype(*proto_msg.string_int_map[i].value)>)val_var;
            }
        }
        // --- Map Field ---
        godot::Dictionary int_msg_map_dict = this->int_msg_map;
        proto_msg.int_msg_map_count = int_msg_map_dict.size();
        if (proto_msg.int_msg_map_count > 0) {
            proto_msg.int_msg_map = (decltype(proto_msg.int_msg_map))malloc(sizeof(*proto_msg.int_msg_map) * proto_msg.int_msg_map_count);
            godot::Array keys = int_msg_map_dict.keys();
            for (int i = 0; i < keys.size(); i++) {
                godot::Variant key_var = keys[i];
                godot::Variant val_var = int_msg_map_dict[key_var];
                
                // Key
                proto_msg.int_msg_map[i].key = (decltype(proto_msg.int_msg_map[i].key))malloc(sizeof(*proto_msg.int_msg_map[i].key));
                *proto_msg.int_msg_map[i].key = (std::decay_t<decltype(*proto_msg.int_msg_map[i].key)>)key_var;

                // Value
                {
                    godot::Object* obj = val_var;
                    BasicTestMessage* wrapper = godot::Object::cast_to<BasicTestMessage>(obj);
                    if (wrapper) {
                         godot::PackedByteArray b = wrapper->to_byte_array();
                         pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
                         // Assuming value message type name via convention if needed, but for now using generic decode
                         // This is likely broken for nested map values without explicit descriptor.
                         // But gdbuf_test uses map<int32, BasicTestMessage>
                         // BasicTestMessage_fields is available.
                         pb_decode(&s, BasicTestMessage_fields, &proto_msg.int_msg_map[i].value);
                    }
                }
            }
        }
        // --- Map Field ---
        godot::Dictionary string_string_map_dict = this->string_string_map;
        proto_msg.string_string_map_count = string_string_map_dict.size();
        if (proto_msg.string_string_map_count > 0) {
            proto_msg.string_string_map = (decltype(proto_msg.string_string_map))malloc(sizeof(*proto_msg.string_string_map) * proto_msg.string_string_map_count);
            godot::Array keys = string_string_map_dict.keys();
            for (int i = 0; i < keys.size(); i++) {
                godot::Variant key_var = keys[i];
                godot::Variant val_var = string_string_map_dict[key_var];
                
                // Key
                {
                    std::string k = ((godot::String)key_var).utf8().get_data();
                    proto_msg.string_string_map[i].key = (char*)malloc(k.size() + 1);
                    memcpy(proto_msg.string_string_map[i].key, k.data(), k.size() + 1);
                }

                // Value
                {
                    std::string v = ((godot::String)val_var).utf8().get_data();
                    proto_msg.string_string_map[i].value = (char*)malloc(v.size() + 1);
                    memcpy(proto_msg.string_string_map[i].value, v.data(), v.size() + 1);
                }
            }
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, MapMessage_fields, &proto_msg)) {
         pb_release(MapMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, MapMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(MapMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error MapMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _MapMessage proto_msg = MapMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, MapMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
        this->string_int_map.clear();
        for (int i = 0; i < proto_msg.string_int_map_count; i++) {
            godot::Variant k;
            godot::Variant v;
            
            // Key
            if (proto_msg.string_int_map[i].key)
                k = godot::String(proto_msg.string_int_map[i].key);
            else
                k = "";

            // Value
            if (proto_msg.string_int_map[i].value)
                v = *proto_msg.string_int_map[i].value;
            else
                v = 0;

            this->string_int_map[k] = v;
        }
        this->int_msg_map.clear();
        for (int i = 0; i < proto_msg.int_msg_map_count; i++) {
            godot::Variant k;
            godot::Variant v;
            
            // Key
            if (proto_msg.int_msg_map[i].key)
                k = *proto_msg.int_msg_map[i].key;
            else
                k = 0;

            // Value
            godot::Ref<BasicTestMessage> wrapper;
            wrapper.instantiate();
            size_t size;
            pb_get_encoded_size(&size, BasicTestMessage_fields, &proto_msg.int_msg_map[i].value);
            godot::PackedByteArray b;
            b.resize(size);
            pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
            pb_encode(&os, BasicTestMessage_fields, &proto_msg.int_msg_map[i].value);
            wrapper->from_byte_array(b);
            v = wrapper;

            this->int_msg_map[k] = v;
        }
        this->string_string_map.clear();
        for (int i = 0; i < proto_msg.string_string_map_count; i++) {
            godot::Variant k;
            godot::Variant v;
            
            // Key
            if (proto_msg.string_string_map[i].key)
                k = godot::String(proto_msg.string_string_map[i].key);
            else
                k = "";

            // Value
            if (proto_msg.string_string_map[i].value)
                v = godot::String(proto_msg.string_string_map[i].value);
            else
                v = "";

            this->string_string_map[k] = v;
        }

    pb_release(MapMessage_fields, &proto_msg);
    return godot::OK;
}
godot::Dictionary MapMessage::get_string_int_map() {
  return string_int_map;
}

void MapMessage::set_string_int_map(godot::Dictionary p_string_int_map) {
  this->string_int_map = p_string_int_map;
}
godot::Dictionary MapMessage::get_int_msg_map() {
  return int_msg_map;
}

void MapMessage::set_int_msg_map(godot::Dictionary p_int_msg_map) {
  this->int_msg_map = p_int_msg_map;
}
godot::Dictionary MapMessage::get_string_string_map() {
  return string_string_map;
}

void MapMessage::set_string_string_map(godot::Dictionary p_string_string_map) {
  this->string_string_map = p_string_string_map;
}

void OuterNestedMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &OuterNestedMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &OuterNestedMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &OuterNestedMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_outer_string"), &OuterNestedMessage::get_outer_string);
  godot::ClassDB::bind_method(godot::D_METHOD("set_outer_string", "value"), &OuterNestedMessage::set_outer_string);
  godot::ClassDB::add_property("OuterNestedMessage", godot::PropertyInfo(godot::Variant::STRING, "outer_string"
      ), "set_outer_string", "get_outer_string");
  godot::ClassDB::bind_method(godot::D_METHOD("get_inner_msg"), &OuterNestedMessage::get_inner_msg);
  godot::ClassDB::bind_method(godot::D_METHOD("set_inner_msg", "value"), &OuterNestedMessage::set_inner_msg);
  godot::ClassDB::add_property("OuterNestedMessage", godot::PropertyInfo(godot::Variant::OBJECT, "inner_msg", godot::PROPERTY_HINT_RESOURCE_TYPE, "OuterNestedMessageInnerNestedMessage"
      ), "set_inner_msg", "get_inner_msg");
}

godot::String OuterNestedMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String OuterNestedMessage::_to_string() const {
    godot::String output = "OuterNestedMessage {";

    output += "outer_string: ";
        output += "\"";
        output += this->outer_string.c_escape();
        output += "\"";
    output += ", ";

    output += "inner_msg: ";
        if (this->inner_msg.is_valid()) {
            output += godot::String(godot::Variant(this->inner_msg));
        } else {
            output += "null";
        }

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray OuterNestedMessage::to_byte_array() const {
    struct _OuterNestedMessage proto_msg = OuterNestedMessage_init_zero;
        // --- Singular Field ---
        {
            std::string s = this->outer_string.utf8().get_data();
            proto_msg.outer_string = (char*)malloc(s.size() + 1);
            memcpy(proto_msg.outer_string, s.data(), s.size() + 1);
        }
        // --- Singular Field ---
        if (inner_msg.is_valid()) {
             godot::PackedByteArray b = inner_msg->to_byte_array();
             // Allocate pointer
             proto_msg.inner_msg = (decltype(proto_msg.inner_msg))malloc(sizeof(*proto_msg.inner_msg));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, OuterNestedMessage_InnerNestedMessage_fields, proto_msg.inner_msg);
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, OuterNestedMessage_fields, &proto_msg)) {
         pb_release(OuterNestedMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, OuterNestedMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(OuterNestedMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error OuterNestedMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _OuterNestedMessage proto_msg = OuterNestedMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, OuterNestedMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
        if (proto_msg.outer_string) {
            this->outer_string = godot::String(proto_msg.outer_string);
        } else {
            this->outer_string = "";
        }
        if (proto_msg.inner_msg != NULL) { // Check pointer presence
             if (!this->inner_msg.is_valid()) this->inner_msg.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, OuterNestedMessage_InnerNestedMessage_fields, proto_msg.inner_msg);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, OuterNestedMessage_InnerNestedMessage_fields, proto_msg.inner_msg);
             this->inner_msg->from_byte_array(b);
        } else {
             this->inner_msg = godot::Ref<OuterNestedMessageInnerNestedMessage>();
        }

    pb_release(OuterNestedMessage_fields, &proto_msg);
    return godot::OK;
}
godot::String OuterNestedMessage::get_outer_string() {
  return outer_string;
}

void OuterNestedMessage::set_outer_string(godot::String p_outer_string) {
  this->outer_string = p_outer_string;
}
godot::Ref<OuterNestedMessageInnerNestedMessage> OuterNestedMessage::get_inner_msg() {
  return inner_msg;
}

void OuterNestedMessage::set_inner_msg(const godot::Ref<OuterNestedMessageInnerNestedMessage> p_inner_msg) {
  this->inner_msg = p_inner_msg;
}

void OuterNestedMessageInnerNestedMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &OuterNestedMessageInnerNestedMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &OuterNestedMessageInnerNestedMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &OuterNestedMessageInnerNestedMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_inner_string"), &OuterNestedMessageInnerNestedMessage::get_inner_string);
  godot::ClassDB::bind_method(godot::D_METHOD("set_inner_string", "value"), &OuterNestedMessageInnerNestedMessage::set_inner_string);
  godot::ClassDB::add_property("OuterNestedMessageInnerNestedMessage", godot::PropertyInfo(godot::Variant::STRING, "inner_string"
      ), "set_inner_string", "get_inner_string");
}

godot::String OuterNestedMessageInnerNestedMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String OuterNestedMessageInnerNestedMessage::_to_string() const {
    godot::String output = "OuterNestedMessageInnerNestedMessage {";

    output += "inner_string: ";
        output += "\"";
        output += this->inner_string.c_escape();
        output += "\"";

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray OuterNestedMessageInnerNestedMessage::to_byte_array() const {
    struct _OuterNestedMessage_InnerNestedMessage proto_msg = OuterNestedMessage_InnerNestedMessage_init_zero;
        // --- Singular Field ---
        {
            std::string s = this->inner_string.utf8().get_data();
            proto_msg.inner_string = (char*)malloc(s.size() + 1);
            memcpy(proto_msg.inner_string, s.data(), s.size() + 1);
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, OuterNestedMessage_InnerNestedMessage_fields, &proto_msg)) {
         pb_release(OuterNestedMessage_InnerNestedMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, OuterNestedMessage_InnerNestedMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(OuterNestedMessage_InnerNestedMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error OuterNestedMessageInnerNestedMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _OuterNestedMessage_InnerNestedMessage proto_msg = OuterNestedMessage_InnerNestedMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, OuterNestedMessage_InnerNestedMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
        if (proto_msg.inner_string) {
            this->inner_string = godot::String(proto_msg.inner_string);
        } else {
            this->inner_string = "";
        }

    pb_release(OuterNestedMessage_InnerNestedMessage_fields, &proto_msg);
    return godot::OK;
}
godot::String OuterNestedMessageInnerNestedMessage::get_inner_string() {
  return inner_string;
}

void OuterNestedMessageInnerNestedMessage::set_inner_string(godot::String p_inner_string) {
  this->inner_string = p_inner_string;
}

void RepeatedComplexMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &RepeatedComplexMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &RepeatedComplexMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &RepeatedComplexMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_messages"), &RepeatedComplexMessage::get_messages);
  godot::ClassDB::bind_method(godot::D_METHOD("set_messages", "value"), &RepeatedComplexMessage::set_messages);
  godot::ClassDB::add_property("RepeatedComplexMessage", godot::PropertyInfo(godot::Variant::ARRAY, "messages", godot::PROPERTY_HINT_NONE, ""
      ), "set_messages", "get_messages");
  godot::ClassDB::bind_method(godot::D_METHOD("get_enums"), &RepeatedComplexMessage::get_enums);
  godot::ClassDB::bind_method(godot::D_METHOD("set_enums", "value"), &RepeatedComplexMessage::set_enums);
  godot::ClassDB::add_property("RepeatedComplexMessage", godot::PropertyInfo(godot::Variant::INT, "enums", godot::PROPERTY_HINT_NONE, ""
      ), "set_enums", "get_enums");
}

godot::String RepeatedComplexMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String RepeatedComplexMessage::_to_string() const {
    godot::String output = "RepeatedComplexMessage {";

    output += "messages: ";
        output += godot::String(godot::Variant(this->messages));
    output += ", ";

    output += "enums: ";
        output += godot::String(godot::Variant(this->enums));

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray RepeatedComplexMessage::to_byte_array() const {
    struct _RepeatedComplexMessage proto_msg = RepeatedComplexMessage_init_zero;
        // --- Repeated Field ---
        godot::Array messages_arr = this->messages;
        proto_msg.messages_count = messages_arr.size();
        if (proto_msg.messages_count > 0) {
            proto_msg.messages = (decltype(proto_msg.messages))malloc(sizeof(*proto_msg.messages) * proto_msg.messages_count);
            // Array of Messages
            for (int i = 0; i < proto_msg.messages_count; i++) {
                godot::Object* obj = messages_arr[i];
                BasicTestMessage* wrapper = godot::Object::cast_to<BasicTestMessage>(obj);
                if (wrapper) {
                     godot::PackedByteArray b = wrapper->to_byte_array();
                     pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
                     pb_decode(&s, BasicTestMessage_fields, &proto_msg.messages[i]);
                } else {
                     proto_msg.messages[i] = BasicTestMessage_init_zero;
                }
            }
        }
        // --- Repeated Field ---
        godot::Array enums_arr = this->enums;
        proto_msg.enums_count = enums_arr.size();
        if (proto_msg.enums_count > 0) {
            proto_msg.enums = (decltype(proto_msg.enums))malloc(sizeof(*proto_msg.enums) * proto_msg.enums_count);
            // Array of Primitives
            for (int i = 0; i < proto_msg.enums_count; i++) {
                 proto_msg.enums[i] = (std::decay_t<decltype(proto_msg.enums[i])>)(int32_t)enums_arr[i];
            }
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, RepeatedComplexMessage_fields, &proto_msg)) {
         pb_release(RepeatedComplexMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, RepeatedComplexMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(RepeatedComplexMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error RepeatedComplexMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _RepeatedComplexMessage proto_msg = RepeatedComplexMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, RepeatedComplexMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
        this->messages.clear();
        for (int i = 0; i < proto_msg.messages_count; i++) {
            godot::Ref<BasicTestMessage> wrapper;
            wrapper.instantiate();
            // Encode struct back to bytes to decode into wrapper... roundabout but works
            size_t size;
            pb_get_encoded_size(&size, BasicTestMessage_fields, &proto_msg.messages[i]);
            godot::PackedByteArray b; 
            b.resize(size);
            pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
            pb_encode(&os, BasicTestMessage_fields, &proto_msg.messages[i]);
            wrapper->from_byte_array(b);
            this->messages.push_back(wrapper);
        }
        this->enums.clear();
        for (int i = 0; i < proto_msg.enums_count; i++) {
            this->enums.push_back(proto_msg.enums[i]);
        }

    pb_release(RepeatedComplexMessage_fields, &proto_msg);
    return godot::OK;
}
godot::Array RepeatedComplexMessage::get_messages() {
  return messages;
}

void RepeatedComplexMessage::set_messages(godot::Array p_messages) {
  this->messages = p_messages;
}
godot::Array RepeatedComplexMessage::get_enums() {
  return enums;
}

void RepeatedComplexMessage::set_enums(godot::Array p_enums) {
  this->enums = p_enums;
}

void RecursiveMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &RecursiveMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &RecursiveMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &RecursiveMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_name"), &RecursiveMessage::get_name);
  godot::ClassDB::bind_method(godot::D_METHOD("set_name", "value"), &RecursiveMessage::set_name);
  godot::ClassDB::add_property("RecursiveMessage", godot::PropertyInfo(godot::Variant::STRING, "name"
      ), "set_name", "get_name");
  godot::ClassDB::bind_method(godot::D_METHOD("get_children"), &RecursiveMessage::get_children);
  godot::ClassDB::bind_method(godot::D_METHOD("set_children", "value"), &RecursiveMessage::set_children);
  godot::ClassDB::add_property("RecursiveMessage", godot::PropertyInfo(godot::Variant::ARRAY, "children", godot::PROPERTY_HINT_NONE, ""
      ), "set_children", "get_children");
  godot::ClassDB::bind_method(godot::D_METHOD("get_parent"), &RecursiveMessage::get_parent);
  godot::ClassDB::bind_method(godot::D_METHOD("set_parent", "value"), &RecursiveMessage::set_parent);
  godot::ClassDB::add_property("RecursiveMessage", godot::PropertyInfo(godot::Variant::OBJECT, "parent", godot::PROPERTY_HINT_RESOURCE_TYPE, "RecursiveMessage"
      ), "set_parent", "get_parent");
}

godot::String RecursiveMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String RecursiveMessage::_to_string() const {
    godot::String output = "RecursiveMessage {";

    output += "name: ";
        output += "\"";
        output += this->name.c_escape();
        output += "\"";
    output += ", ";

    output += "children: ";
        output += godot::String(godot::Variant(this->children));
    output += ", ";

    output += "parent: ";
        if (this->parent.is_valid()) {
            output += godot::String(godot::Variant(this->parent));
        } else {
            output += "null";
        }

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray RecursiveMessage::to_byte_array() const {
    struct _RecursiveMessage proto_msg = RecursiveMessage_init_zero;
        // --- Singular Field ---
        {
            std::string s = this->name.utf8().get_data();
            proto_msg.name = (char*)malloc(s.size() + 1);
            memcpy(proto_msg.name, s.data(), s.size() + 1);
        }
        // --- Repeated Field ---
        godot::Array children_arr = this->children;
        proto_msg.children_count = children_arr.size();
        if (proto_msg.children_count > 0) {
            proto_msg.children = (decltype(proto_msg.children))malloc(sizeof(*proto_msg.children) * proto_msg.children_count);
            // Array of Messages
            for (int i = 0; i < proto_msg.children_count; i++) {
                godot::Object* obj = children_arr[i];
                RecursiveMessage* wrapper = godot::Object::cast_to<RecursiveMessage>(obj);
                if (wrapper) {
                     godot::PackedByteArray b = wrapper->to_byte_array();
                     pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
                     pb_decode(&s, RecursiveMessage_fields, &proto_msg.children[i]);
                } else {
                     proto_msg.children[i] = RecursiveMessage_init_zero;
                }
            }
        }
        // --- Singular Field ---
        if (parent.is_valid()) {
             godot::PackedByteArray b = parent->to_byte_array();
             // Allocate pointer
             proto_msg.parent = (decltype(proto_msg.parent))malloc(sizeof(*proto_msg.parent));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, RecursiveMessage_fields, proto_msg.parent);
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, RecursiveMessage_fields, &proto_msg)) {
         pb_release(RecursiveMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, RecursiveMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(RecursiveMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error RecursiveMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _RecursiveMessage proto_msg = RecursiveMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, RecursiveMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
        if (proto_msg.name) {
            this->name = godot::String(proto_msg.name);
        } else {
            this->name = "";
        }
        this->children.clear();
        for (int i = 0; i < proto_msg.children_count; i++) {
            godot::Ref<RecursiveMessage> wrapper;
            wrapper.instantiate();
            // Encode struct back to bytes to decode into wrapper... roundabout but works
            size_t size;
            pb_get_encoded_size(&size, RecursiveMessage_fields, &proto_msg.children[i]);
            godot::PackedByteArray b; 
            b.resize(size);
            pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
            pb_encode(&os, RecursiveMessage_fields, &proto_msg.children[i]);
            wrapper->from_byte_array(b);
            this->children.push_back(wrapper);
        }
        if (proto_msg.parent != NULL) { // Check pointer presence
             if (!this->parent.is_valid()) this->parent.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, RecursiveMessage_fields, proto_msg.parent);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, RecursiveMessage_fields, proto_msg.parent);
             this->parent->from_byte_array(b);
        } else {
             this->parent = godot::Ref<RecursiveMessage>();
        }

    pb_release(RecursiveMessage_fields, &proto_msg);
    return godot::OK;
}
godot::String RecursiveMessage::get_name() {
  return name;
}

void RecursiveMessage::set_name(godot::String p_name) {
  this->name = p_name;
}
godot::Array RecursiveMessage::get_children() {
  return children;
}

void RecursiveMessage::set_children(godot::Array p_children) {
  this->children = p_children;
}
godot::Ref<RecursiveMessage> RecursiveMessage::get_parent() {
  return parent;
}

void RecursiveMessage::set_parent(const godot::Ref<RecursiveMessage> p_parent) {
  this->parent = p_parent;
}

void ReservedMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &ReservedMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &ReservedMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &ReservedMessage::from_byte_array);
}

godot::String ReservedMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String ReservedMessage::_to_string() const {
    godot::String output = "ReservedMessage {";

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray ReservedMessage::to_byte_array() const {
    struct _ReservedMessage proto_msg = ReservedMessage_init_zero; // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, ReservedMessage_fields, &proto_msg)) {
         pb_release(ReservedMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, ReservedMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(ReservedMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error ReservedMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _ReservedMessage proto_msg = ReservedMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, ReservedMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first

    pb_release(ReservedMessage_fields, &proto_msg);
    return godot::OK;
}

void EverythingMessage::_bind_methods() {
  godot::ClassDB::bind_method(godot::D_METHOD("get_proto_file_name"), &EverythingMessage::get_proto_file_name);
  godot::ClassDB::bind_method(godot::D_METHOD("to_byte_array"), &EverythingMessage::to_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("from_byte_array", "PackedByteArray"), &EverythingMessage::from_byte_array);
  godot::ClassDB::bind_method(godot::D_METHOD("get_basic_message"), &EverythingMessage::get_basic_message);
  godot::ClassDB::bind_method(godot::D_METHOD("set_basic_message", "value"), &EverythingMessage::set_basic_message);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "basic_message", godot::PROPERTY_HINT_RESOURCE_TYPE, "BasicTestMessage"
      ), "set_basic_message", "get_basic_message");
  godot::ClassDB::bind_method(godot::D_METHOD("get_special_message"), &EverythingMessage::get_special_message);
  godot::ClassDB::bind_method(godot::D_METHOD("set_special_message", "value"), &EverythingMessage::set_special_message);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "special_message", godot::PROPERTY_HINT_RESOURCE_TYPE, "SpecialFieldTypesMessage"
      ), "set_special_message", "get_special_message");
  godot::ClassDB::bind_method(godot::D_METHOD("get_map_message"), &EverythingMessage::get_map_message);
  godot::ClassDB::bind_method(godot::D_METHOD("set_map_message", "value"), &EverythingMessage::set_map_message);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "map_message", godot::PROPERTY_HINT_RESOURCE_TYPE, "MapMessage"
      ), "set_map_message", "get_map_message");
  godot::ClassDB::bind_method(godot::D_METHOD("get_oneof_message"), &EverythingMessage::get_oneof_message);
  godot::ClassDB::bind_method(godot::D_METHOD("set_oneof_message", "value"), &EverythingMessage::set_oneof_message);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "oneof_message", godot::PROPERTY_HINT_RESOURCE_TYPE, "OneOfMessage"
      ), "set_oneof_message", "get_oneof_message");
  godot::ClassDB::bind_method(godot::D_METHOD("get_nested_message"), &EverythingMessage::get_nested_message);
  godot::ClassDB::bind_method(godot::D_METHOD("set_nested_message", "value"), &EverythingMessage::set_nested_message);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "nested_message", godot::PROPERTY_HINT_RESOURCE_TYPE, "OuterNestedMessage"
      ), "set_nested_message", "get_nested_message");
  godot::ClassDB::bind_method(godot::D_METHOD("get_well_known_types_message"), &EverythingMessage::get_well_known_types_message);
  godot::ClassDB::bind_method(godot::D_METHOD("set_well_known_types_message", "value"), &EverythingMessage::set_well_known_types_message);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "well_known_types_message", godot::PROPERTY_HINT_RESOURCE_TYPE, "GoogleWellKnownTypesMessage"
      ), "set_well_known_types_message", "get_well_known_types_message");
  godot::ClassDB::bind_method(godot::D_METHOD("get_basic_enum"), &EverythingMessage::get_basic_enum);
  godot::ClassDB::bind_method(godot::D_METHOD("set_basic_enum", "value"), &EverythingMessage::set_basic_enum);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::INT, "basic_enum"
      ), "set_basic_enum", "get_basic_enum");
  godot::ClassDB::bind_method(godot::D_METHOD("get_dependency_message"), &EverythingMessage::get_dependency_message);
  godot::ClassDB::bind_method(godot::D_METHOD("set_dependency_message", "value"), &EverythingMessage::set_dependency_message);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "dependency_message", godot::PROPERTY_HINT_RESOURCE_TYPE, "DependencyMessage"
      ), "set_dependency_message", "get_dependency_message");
  godot::ClassDB::bind_method(godot::D_METHOD("get_repeated_complex"), &EverythingMessage::get_repeated_complex);
  godot::ClassDB::bind_method(godot::D_METHOD("set_repeated_complex", "value"), &EverythingMessage::set_repeated_complex);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "repeated_complex", godot::PROPERTY_HINT_RESOURCE_TYPE, "RepeatedComplexMessage"
      ), "set_repeated_complex", "get_repeated_complex");
  godot::ClassDB::bind_method(godot::D_METHOD("get_recursive"), &EverythingMessage::get_recursive);
  godot::ClassDB::bind_method(godot::D_METHOD("set_recursive", "value"), &EverythingMessage::set_recursive);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "recursive", godot::PROPERTY_HINT_RESOURCE_TYPE, "RecursiveMessage"
      ), "set_recursive", "get_recursive");
  godot::ClassDB::bind_method(godot::D_METHOD("get_deeply_nested"), &EverythingMessage::get_deeply_nested);
  godot::ClassDB::bind_method(godot::D_METHOD("set_deeply_nested", "value"), &EverythingMessage::set_deeply_nested);
  godot::ClassDB::add_property("EverythingMessage", godot::PropertyInfo(godot::Variant::OBJECT, "deeply_nested", godot::PROPERTY_HINT_RESOURCE_TYPE, "DeeplyNestedMessage"
      ), "set_deeply_nested", "get_deeply_nested");
}

godot::String EverythingMessage::get_proto_file_name() {
  return godot::String("gdbuf_test");
}

godot::String EverythingMessage::_to_string() const {
    godot::String output = "EverythingMessage {";

    output += "basic_message: ";
        if (this->basic_message.is_valid()) {
            output += godot::String(godot::Variant(this->basic_message));
        } else {
            output += "null";
        }
    output += ", ";

    output += "special_message: ";
        if (this->special_message.is_valid()) {
            output += godot::String(godot::Variant(this->special_message));
        } else {
            output += "null";
        }
    output += ", ";

    output += "map_message: ";
        if (this->map_message.is_valid()) {
            output += godot::String(godot::Variant(this->map_message));
        } else {
            output += "null";
        }
    output += ", ";

    output += "oneof_message: ";
        if (this->oneof_message.is_valid()) {
            output += godot::String(godot::Variant(this->oneof_message));
        } else {
            output += "null";
        }
    output += ", ";

    output += "nested_message: ";
        if (this->nested_message.is_valid()) {
            output += godot::String(godot::Variant(this->nested_message));
        } else {
            output += "null";
        }
    output += ", ";

    output += "well_known_types_message: ";
        if (this->well_known_types_message.is_valid()) {
            output += godot::String(godot::Variant(this->well_known_types_message));
        } else {
            output += "null";
        }
    output += ", ";

    output += "basic_enum: ";
        output += godot::String(godot::Variant(this->basic_enum));
    output += ", ";

    output += "dependency_message: ";
        if (this->dependency_message.is_valid()) {
            output += godot::String(godot::Variant(this->dependency_message));
        } else {
            output += "null";
        }
    output += ", ";

    output += "repeated_complex: ";
        if (this->repeated_complex.is_valid()) {
            output += godot::String(godot::Variant(this->repeated_complex));
        } else {
            output += "null";
        }
    output += ", ";

    output += "recursive: ";
        if (this->recursive.is_valid()) {
            output += godot::String(godot::Variant(this->recursive));
        } else {
            output += "null";
        }
    output += ", ";

    output += "deeply_nested: ";
        if (this->deeply_nested.is_valid()) {
            output += godot::String(godot::Variant(this->deeply_nested));
        } else {
            output += "null";
        }

    output += "}";
    return output;
}

// Serialize
godot::PackedByteArray EverythingMessage::to_byte_array() const {
    struct _EverythingMessage proto_msg = EverythingMessage_init_zero;
        // --- Singular Field ---
        if (basic_message.is_valid()) {
             godot::PackedByteArray b = basic_message->to_byte_array();
             // Allocate pointer
             proto_msg.basic_message = (decltype(proto_msg.basic_message))malloc(sizeof(*proto_msg.basic_message));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, BasicTestMessage_fields, proto_msg.basic_message);
        }
        // --- Singular Field ---
        if (special_message.is_valid()) {
             godot::PackedByteArray b = special_message->to_byte_array();
             // Allocate pointer
             proto_msg.special_message = (decltype(proto_msg.special_message))malloc(sizeof(*proto_msg.special_message));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, SpecialFieldTypesMessage_fields, proto_msg.special_message);
        }
        // --- Singular Field ---
        if (map_message.is_valid()) {
             godot::PackedByteArray b = map_message->to_byte_array();
             // Allocate pointer
             proto_msg.map_message = (decltype(proto_msg.map_message))malloc(sizeof(*proto_msg.map_message));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, MapMessage_fields, proto_msg.map_message);
        }
        // --- Singular Field ---
        if (oneof_message.is_valid()) {
             godot::PackedByteArray b = oneof_message->to_byte_array();
             // Allocate pointer
             proto_msg.oneof_message = (decltype(proto_msg.oneof_message))malloc(sizeof(*proto_msg.oneof_message));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, OneOfMessage_fields, proto_msg.oneof_message);
        }
        // --- Singular Field ---
        if (nested_message.is_valid()) {
             godot::PackedByteArray b = nested_message->to_byte_array();
             // Allocate pointer
             proto_msg.nested_message = (decltype(proto_msg.nested_message))malloc(sizeof(*proto_msg.nested_message));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, OuterNestedMessage_fields, proto_msg.nested_message);
        }
        // --- Singular Field ---
        if (well_known_types_message.is_valid()) {
             godot::PackedByteArray b = well_known_types_message->to_byte_array();
             // Allocate pointer
             proto_msg.well_known_types_message = (decltype(proto_msg.well_known_types_message))malloc(sizeof(*proto_msg.well_known_types_message));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, GoogleWellKnownTypesMessage_fields, proto_msg.well_known_types_message);
        }
        // --- Singular Field ---
        // Primitive pointer allocation
        proto_msg.basic_enum = (decltype(proto_msg.basic_enum))malloc(sizeof(*proto_msg.basic_enum));
        *proto_msg.basic_enum = (decltype(*proto_msg.basic_enum))this->basic_enum;
        // --- Singular Field ---
        if (dependency_message.is_valid()) {
             godot::PackedByteArray b = dependency_message->to_byte_array();
             // Allocate pointer
             proto_msg.dependency_message = (decltype(proto_msg.dependency_message))malloc(sizeof(*proto_msg.dependency_message));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, dependency_DependencyMessage_fields, proto_msg.dependency_message);
        }
        // --- Singular Field ---
        if (repeated_complex.is_valid()) {
             godot::PackedByteArray b = repeated_complex->to_byte_array();
             // Allocate pointer
             proto_msg.repeated_complex = (decltype(proto_msg.repeated_complex))malloc(sizeof(*proto_msg.repeated_complex));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, RepeatedComplexMessage_fields, proto_msg.repeated_complex);
        }
        // --- Singular Field ---
        if (recursive.is_valid()) {
             godot::PackedByteArray b = recursive->to_byte_array();
             // Allocate pointer
             proto_msg.recursive = (decltype(proto_msg.recursive))malloc(sizeof(*proto_msg.recursive));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, RecursiveMessage_fields, proto_msg.recursive);
        }
        // --- Singular Field ---
        if (deeply_nested.is_valid()) {
             godot::PackedByteArray b = deeply_nested->to_byte_array();
             // Allocate pointer
             proto_msg.deeply_nested = (decltype(proto_msg.deeply_nested))malloc(sizeof(*proto_msg.deeply_nested));
             pb_istream_t s = pb_istream_from_buffer(b.ptr(), b.size());
             pb_decode(&s, nested_deeply_DeeplyNestedMessage_fields, proto_msg.deeply_nested);
        } // End fields

    size_t encoded_size;
    if (!pb_get_encoded_size(&encoded_size, EverythingMessage_fields, &proto_msg)) {
         pb_release(EverythingMessage_fields, &proto_msg);
         return godot::PackedByteArray();
    }

    godot::PackedByteArray ret;
    ret.resize(encoded_size);
    pb_ostream_t stream = pb_ostream_from_buffer(ret.ptrw(), encoded_size);
    
    if (!pb_encode(&stream, EverythingMessage_fields, &proto_msg)) {
         godot::UtilityFunctions::printerr("Nanopb encoding failed: ", stream.errmsg);
    }
    
    pb_release(EverythingMessage_fields, &proto_msg);
    return ret;
}

// Deserialize
godot::Error EverythingMessage::from_byte_array(const godot::PackedByteArray &p_bytes) {
    struct _EverythingMessage proto_msg = EverythingMessage_init_zero;
    pb_istream_t stream = pb_istream_from_buffer(p_bytes.ptr(), p_bytes.size());

    if (!pb_decode(&stream, EverythingMessage_fields, &proto_msg)) {
        godot::UtilityFunctions::printerr("Nanopb decoding failed: ", stream.errmsg);
        return godot::ERR_PARSE_ERROR;
    }

    // Map back to Godot
    // Clear Oneofs first
        if (proto_msg.basic_message != NULL) { // Check pointer presence
             if (!this->basic_message.is_valid()) this->basic_message.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, BasicTestMessage_fields, proto_msg.basic_message);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, BasicTestMessage_fields, proto_msg.basic_message);
             this->basic_message->from_byte_array(b);
        } else {
             this->basic_message = godot::Ref<BasicTestMessage>();
        }
        if (proto_msg.special_message != NULL) { // Check pointer presence
             if (!this->special_message.is_valid()) this->special_message.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, SpecialFieldTypesMessage_fields, proto_msg.special_message);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, SpecialFieldTypesMessage_fields, proto_msg.special_message);
             this->special_message->from_byte_array(b);
        } else {
             this->special_message = godot::Ref<SpecialFieldTypesMessage>();
        }
        if (proto_msg.map_message != NULL) { // Check pointer presence
             if (!this->map_message.is_valid()) this->map_message.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, MapMessage_fields, proto_msg.map_message);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, MapMessage_fields, proto_msg.map_message);
             this->map_message->from_byte_array(b);
        } else {
             this->map_message = godot::Ref<MapMessage>();
        }
        if (proto_msg.oneof_message != NULL) { // Check pointer presence
             if (!this->oneof_message.is_valid()) this->oneof_message.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, OneOfMessage_fields, proto_msg.oneof_message);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, OneOfMessage_fields, proto_msg.oneof_message);
             this->oneof_message->from_byte_array(b);
        } else {
             this->oneof_message = godot::Ref<OneOfMessage>();
        }
        if (proto_msg.nested_message != NULL) { // Check pointer presence
             if (!this->nested_message.is_valid()) this->nested_message.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, OuterNestedMessage_fields, proto_msg.nested_message);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, OuterNestedMessage_fields, proto_msg.nested_message);
             this->nested_message->from_byte_array(b);
        } else {
             this->nested_message = godot::Ref<OuterNestedMessage>();
        }
        if (proto_msg.well_known_types_message != NULL) { // Check pointer presence
             if (!this->well_known_types_message.is_valid()) this->well_known_types_message.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, GoogleWellKnownTypesMessage_fields, proto_msg.well_known_types_message);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, GoogleWellKnownTypesMessage_fields, proto_msg.well_known_types_message);
             this->well_known_types_message->from_byte_array(b);
        } else {
             this->well_known_types_message = godot::Ref<GoogleWellKnownTypesMessage>();
        }
        // Primitive pointer
        if (proto_msg.basic_enum != NULL) {
            this->basic_enum = (int32_t)*proto_msg.basic_enum;
        } else {
            this->basic_enum = (int32_t)0;
        }
        if (proto_msg.dependency_message != NULL) { // Check pointer presence
             if (!this->dependency_message.is_valid()) this->dependency_message.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, dependency_DependencyMessage_fields, proto_msg.dependency_message);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, dependency_DependencyMessage_fields, proto_msg.dependency_message);
             this->dependency_message->from_byte_array(b);
        } else {
             this->dependency_message = godot::Ref<gdbuf::dependency::DependencyMessage>();
        }
        if (proto_msg.repeated_complex != NULL) { // Check pointer presence
             if (!this->repeated_complex.is_valid()) this->repeated_complex.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, RepeatedComplexMessage_fields, proto_msg.repeated_complex);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, RepeatedComplexMessage_fields, proto_msg.repeated_complex);
             this->repeated_complex->from_byte_array(b);
        } else {
             this->repeated_complex = godot::Ref<RepeatedComplexMessage>();
        }
        if (proto_msg.recursive != NULL) { // Check pointer presence
             if (!this->recursive.is_valid()) this->recursive.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, RecursiveMessage_fields, proto_msg.recursive);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, RecursiveMessage_fields, proto_msg.recursive);
             this->recursive->from_byte_array(b);
        } else {
             this->recursive = godot::Ref<RecursiveMessage>();
        }
        if (proto_msg.deeply_nested != NULL) { // Check pointer presence
             if (!this->deeply_nested.is_valid()) this->deeply_nested.instantiate();
             // Roundtrip via bytes
             size_t size;
             pb_get_encoded_size(&size, nested_deeply_DeeplyNestedMessage_fields, proto_msg.deeply_nested);
             godot::PackedByteArray b;
             b.resize(size);
             pb_ostream_t os = pb_ostream_from_buffer(b.ptrw(), size);
             pb_encode(&os, nested_deeply_DeeplyNestedMessage_fields, proto_msg.deeply_nested);
             this->deeply_nested->from_byte_array(b);
        } else {
             this->deeply_nested = godot::Ref<gdbuf::nested::DeeplyNestedMessage>();
        }

    pb_release(EverythingMessage_fields, &proto_msg);
    return godot::OK;
}
godot::Ref<BasicTestMessage> EverythingMessage::get_basic_message() {
  return basic_message;
}

void EverythingMessage::set_basic_message(const godot::Ref<BasicTestMessage> p_basic_message) {
  this->basic_message = p_basic_message;
}
godot::Ref<SpecialFieldTypesMessage> EverythingMessage::get_special_message() {
  return special_message;
}

void EverythingMessage::set_special_message(const godot::Ref<SpecialFieldTypesMessage> p_special_message) {
  this->special_message = p_special_message;
}
godot::Ref<MapMessage> EverythingMessage::get_map_message() {
  return map_message;
}

void EverythingMessage::set_map_message(const godot::Ref<MapMessage> p_map_message) {
  this->map_message = p_map_message;
}
godot::Ref<OneOfMessage> EverythingMessage::get_oneof_message() {
  return oneof_message;
}

void EverythingMessage::set_oneof_message(const godot::Ref<OneOfMessage> p_oneof_message) {
  this->oneof_message = p_oneof_message;
}
godot::Ref<OuterNestedMessage> EverythingMessage::get_nested_message() {
  return nested_message;
}

void EverythingMessage::set_nested_message(const godot::Ref<OuterNestedMessage> p_nested_message) {
  this->nested_message = p_nested_message;
}
godot::Ref<GoogleWellKnownTypesMessage> EverythingMessage::get_well_known_types_message() {
  return well_known_types_message;
}

void EverythingMessage::set_well_known_types_message(const godot::Ref<GoogleWellKnownTypesMessage> p_well_known_types_message) {
  this->well_known_types_message = p_well_known_types_message;
}
int32_t EverythingMessage::get_basic_enum() {
  return basic_enum;
}

void EverythingMessage::set_basic_enum(int32_t p_basic_enum) {
  this->basic_enum = p_basic_enum;
}
godot::Ref<gdbuf::dependency::DependencyMessage> EverythingMessage::get_dependency_message() {
  return dependency_message;
}

void EverythingMessage::set_dependency_message(const godot::Ref<gdbuf::dependency::DependencyMessage> p_dependency_message) {
  this->dependency_message = p_dependency_message;
}
godot::Ref<RepeatedComplexMessage> EverythingMessage::get_repeated_complex() {
  return repeated_complex;
}

void EverythingMessage::set_repeated_complex(const godot::Ref<RepeatedComplexMessage> p_repeated_complex) {
  this->repeated_complex = p_repeated_complex;
}
godot::Ref<RecursiveMessage> EverythingMessage::get_recursive() {
  return recursive;
}

void EverythingMessage::set_recursive(const godot::Ref<RecursiveMessage> p_recursive) {
  this->recursive = p_recursive;
}
godot::Ref<gdbuf::nested::DeeplyNestedMessage> EverythingMessage::get_deeply_nested() {
  return deeply_nested;
}

void EverythingMessage::set_deeply_nested(const godot::Ref<gdbuf::nested::DeeplyNestedMessage> p_deeply_nested) {
  this->deeply_nested = p_deeply_nested;
}
}
}
